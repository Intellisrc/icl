//file:noinspection unused
package com.intellisrc.crypt.encode

import com.intellisrc.core.Log
import groovy.transform.CompileStatic

import java.lang.reflect.Modifier
import java.nio.CharBuffer
import java.nio.charset.StandardCharsets
import java.util.regex.Pattern

/*
 * @author: A.Lepe
 * @since: Sep 10,2010 (Originally created in PHP for Yayahuic Framework)
 *
 * This class provides 2-way string encoding as a way of obfuscation.
 * While it doesn't really provide security, it could be used to
 * create confusion or to reduce the storage size of a string (see notes).
 * Or... you can use it just for fun! :)
 *
 * Features:
 * - Use of uncommon methods to encode/decode strings
 * - a salt key can be used to change output
 * - 2 Planes of UTF-8 can be used (128k+ chars) (see notes).
 * - Depending on the settings, the encoded string may
 *   result smaller than the length of the original string.
 * - Many possible combinations (input, output).
 * - Translation from one charset to another.
 * - Get a numeric representation of a string
 *
 * NOTES:
 *  1. If you encode, for example, from HASH (16 chars) to ALPHA (52 chars) the resulting
 *     string length will be smaller than the original string. The opposite is also true:
 *     If you encode an alphanumeric string (ALPHA) to NUMBERS (10 chars), the resulting
 *     string length will be longer than the original string.
 *  2. If you store data and you use any of the characters inside the SMP (Plane 2), which
 *     are composed of 4 bytes, you may need prepare your code to handle such strings. For
 *     example:
 *     "Êó•Êú¨Ë™û".toCharArray().length == 3  // Any character inside the BMP (Basic Multilingual Plane) can be stored inside a `char`
 *     "üïôü´õüé∏üõ°".toCharArray().length == 8 // Instead of iterating over those characters you will need to use getCodePoints() method.
 *
 * In order to decode/decode a string 2 settings are required:
 *
 * 1) INPUT: Is the expected format of the string to encode (Default: BASIC).
 *
 * Closest the charset to the input, the smaller is the resulted encoded string.
 * For example, if only numbers are to being encoded, use NUM.
 * If the string to be encoded contains one or more characters not presented
 *      in the selected charset, the result will be garbage.
 * If the input string is a hash (MD5, SHA*, etc), use "HASH".
 * If a string is the result of an encoding method such as base64, unpack('H*',...) ]
 *      it is recommended to use "BASE64".
 * Crypt hashes (created by an standard Unix DES-based algorithm) may contain any ascii
 *      character when using salt strings, as those are stored within the hash itself.
 *      For that reason, use BASIC or LATIN as input.
 * Even for the same string, different "INPUT" methods may result in different
 * encoded strings.
 *
 * 2) OUTPUT: Is the expected format AFTER being encoded (Default: ANUM).
 *
 * Wider the charset used, the smaller is the resulted encoded string.
 * Using the full UTF8 range (65k+) results in the highest entropy, but
 *      it may present some problems handling the resulted string.
 * Some visually interesting outputs are BRAILLE and LINES.
 * After UTF8, KANJI or KOR provides the wider ranges, giving a higher entropy.
 * INVISIBLE may provide an extra difficulty to read as are not visual characters.
 * ALPHA,ANUM,HASH,LCASE,UCASE,NUM are safe to store (as in a DB) without worrying about
 * escaping chars or having problems with language encoding.
 *
 * 3) KEY: used to randomize output. It is optional.
 *
 * NOTE: There is no font that will display all characters in this list.
 *       Some fonts of the most complete are:
 *
 * Recommended fonts:
 *  - Noto - Google (77,000 characters)
 *  - Unifont (65,000 characters)
 *  - Dejavu (6,000 characters)
 *
 * Fonts marked with [**] may require specific font to display
 *
 * https://www.ssec.wisc.edu/~tomw/java/unicode.html
 * https://en.wikipedia.org/wiki/Unicode_block
 * http://www.unicode.org/charts/
 */

@CompileStatic
class LpCode {
    //NOTE: The smaller the chunkSize, the larger the output, higher the CPU usage and lower the Memory usage.
    int chunkSize = 100      //For large size texts, it is better to use chunks (for very large texts, 1024 might be better)
    int glueChar = 0x1E      //Which character to use to glue a chunk (it can be part of the OUTPUT charset)
    /* ************ PARTS ***************** */
    //Binary-like (2 chars: 0,1) : 10111010111011111010100111000011111101000101000100
    static public final List<Integer> BIT = 0x30..0x31
    //Space character (used only to complement any other)
    static public final List<Integer> SPACE = [0x20]
    //New line characters. Use it when your text might contain new line characters (return character and line feed)
    static public final List<Integer> NEWLINES = [0x0A,0x0D]
    // = and + symbols (2 chars) : Used to complement others : +===+=+=++=++=+=+=++=
    static public final List<Integer> EQUALPLUS = [0x3D, 0x2B]
    // a to f (6 chars) : ebacedaebfccedafcfaeeeefbacaef
    static public final List<Integer> aTof = 0x61..0x66
    // A to F (6 chars) : CCEEFEBEFEFCCAACFCFEBACEDAEBFCCEDA
    static public final List<Integer> AtoF = 0x41..0x46
    //0-9 (10 digits) : 058507141981398903957820054
    static public final List<Integer> NUMBERS = 0x30..0x39
    //a-z (26 chars) : iofwbwhqvtjdtglpsuxvpjomkrinrzkfgb
    static public final List<Integer> LOWERCASE = 0x61..0x7A
    //A-Z (26 chars) : YRXAFMKZCIOFWBWHQVTJDTGLPSU
    static public final List<Integer> UPPERCASE = 0x41..0x5A

    /* ************ BLOCKS **************** */
    //Any English ascii char (96 chars) : r~<s>3,o2F$%]<|5tu^9bmfN>R^
    static public final List<Integer> BASIC = 0x20..0x7F
    //Extended Ascii (without BASIC) (719 chars) : √Ç≈Ö ö∆µ»≤…≠ µÀø…†»†∆∏Ãπ≈îÃ¥«Ö∆õ ∏»ï»¥¬≥…≠≈†Ã©Õß
    static public final List<Integer> EXTENDED = 0xA1..0x036F
    // Latin (inc. COMBINING) ( 91 chars) : ·µéÍûæ‚±Ø·ª°Í¨∂·π≠‚±®·π•·∑É·ª´·∏≠·∫≠·∑ΩÍûö·∂î·¥á·∫ÆÍûë·πä·∑É‚±∞Í¨πÍûé·ªø
    static public final List<Integer> LATIN = (0x1D00..0x1D65) + (0x1D6B..0x1EFF) + (0x1AB0..0x1AC0) + (0x2C60..0x2C7F) -
        [0x1DFA, 0xA7C0, 0xA7C1] + (0xA722..0xA7CA) + (0xA7F2..0xA7FF) + (0xAB30..0xAB64)
    // Greek (344 chars) : Õº·æß·ΩÉŒºŒ†·ΩõŒï·ø∑·ºõ·º∏·Ω±·øæ·ø™ŒóœÄ·ºß·øù·º´·ºò·º∂·ææ
    static public final List<Integer> GREEK = (0x0370..0x03E1) + (0x1D66..0x1D6A) + (0x1F00..0x1FFE) -
        [0x0378, 0x0379, 0x0380, 0x0381, 0x0382, 0x0383, 0x038B, 0x038D, 0x03A2, 0x1F16, 0x1F17,
         0x1F1E, 0x1F1F, 0x1F46, 0x1F47, 0x1F4E, 0x1F4F, 0x1F58, 0x1F5A, 0x1F5C, 0x1F5E, 0x1F7E,
         0x1F7F, 0x1FB5, 0x1FC5, 0x1FD4, 0x1FD5, 0x1FDC, 0x1FF0, 0x1FF1, 0x1FF5] + [0xAB65]
    // Cyrillic (265 chars) : ÍôüÍô≠–ØÍôùÍöå—òÍöó—å—≠ÍôØ‚∑º—á–É—á‚∑ª–§Íöü–≥–Æ
    static public final List<Integer> CYRILLIC = (0x0400..0x047F) + (0x1C80..0x1C88) + (0x2DE0..0x2DFF) + (0xA640..0xA69F)
    // Armenian (93 chars) : ÷à’≥’Ø’æ’∏’Å’û’è’ü’ø÷Ä’Ç’ô’≤’â÷Ñ’á÷Ñ‘±’Ü’ü’ê’∫’ã
    static public final List<Integer> ARMENIAN = (0x0531..0x058A) - [0x0557, 0x0558] + (0xFB13..0xFB17)
    // Hebrew (133 chars) : ◊≤◊úÔ¨∏÷∞◊úÔ¨°÷º◊Ü÷´Ô¨üÔ¨®÷±Ô¨±◊óÔ≠ä÷†Ô¨∫Ô¨û÷¨÷ò÷≤◊òÔ≠Ü÷≠Ô¨∞÷ú
    static public final List<Integer> HEBREW = (0x0591..0x05F4) - (0x05C8..0x05CF) - (0x05EB..0x05EF) + (0xFB1D..0xFB4F) -
        [0xFB37, 0xFB3D, 0xFB3F, 0xFB42, 0xFB45]
    // Arabic (1109 chars) : ‡£µÔ∫´ÔÆΩ€£ÿ¨Ô∫§ŸÑÔªºÔ±ÇÔ∑∫ÔµùÔªûÔπø€ôÔ≤§Ô∞æÔ±øÔµ∏
    static public final List<Integer> ARABIC = (0x0600..0x06FF) + (0x08A0..0x08FF) - [0x061D, 0x08B5] - (0x08C8..0x08D2) +
        (0xFB50..0xFBC1) + (0xFBD3..0xFDC7) - [0xFD90, 0xFD91] + [0xFDCF] + (0xFDF0..0xFDFF) +
        (0xFE70..0xFEFC) - [0xFE76]
    // Syriac (108 chars) : ‹∏‹Ç›á‹à›ë‹∞›™‹¨‹ö‹º›Ç›¢‹ê‹à›Ø‹∂‹•‹Æ‹à›£›è‹≥‹ö‹§‹Æ‹∑›©‹ó›Ö‹Ø›ù›ö‹ç›í
    static public final List<Integer> SYRIAC = (0x0700..0x076F) - [0x070E, 0x070F, 0x074B, 0x074C]

    // Thaana - Maldivas (50 chars) : ﬁîﬁüﬁ¢ﬁñﬁßﬁèﬁôﬁØﬁÅﬁ§ﬁ™ﬁÄﬁüﬁÄﬁÖﬁ∞ﬁíﬁ©ﬁüﬁéﬁ¨ﬁîﬁõﬁïﬁ≠ﬁßﬁßﬁÆﬁ£ﬁöﬁÖﬁïﬁ´ﬁ´ﬁ£ﬁ£ﬁãﬁ§ﬁïﬁ®ﬁ™ﬁ±ﬁíﬁçﬁÄ
    static public final List<Integer> THAANA = 0x0780..0x07B1
    // NKO - West Africa (62 chars) : ﬂÖﬂïﬂõﬂåﬂ≥ﬂ¢ﬂ≠ﬂ•ﬂáﬂîﬂüﬂæﬂèﬂâﬂ£ﬂ®ﬂ≠ﬂÉﬂπﬂàﬂìﬂÄﬂô
    static public final List<Integer> NKO = (0x07C0..0x07FF) - [0x07FB, 0x07FC]
    // Samaritan - Aramaic (ancient Greek, Arabic and Hebrew) (62 chars) : ‡†µ‡†ò‡†Ñ‡†¨‡†ì‡†≠‡†∞‡†ª‡†Ö‡†ï‡†õ‡†å‡†µ‡†¢‡†≠‡†•‡†á‡†î‡†ü‡†æ‡†è‡†â‡†£‡†®‡†≠‡†É‡†ª‡†à‡†ì‡†Ä‡†ô‡†®‡†®‡†≥‡†∑‡†à‡†ß‡†Ñ‡†î‡†Ñ
    static public final List<Integer> SAMARITAN = (0x0800..0x083F) - [0x082E, 0x082F]
    // Mandaic - Southeastern Aramaic (Iraq, Iran) (29 chars) : Not available in some fonts
    static public final List<Integer> MANDAIC = (0x0840..0x085B) + [0x085E]
    // Devanagari - India (160 chars) : ‡§©‡§â‡§º‡•Å‡§∫‡•©‡§´‡§¨‡§Ö‡§†‡•πÍ£ª‡•ì‡§ê‡§ΩÍ£Æ‡§õ‡•ñ‡§Å‡•Ä‡§å‡•ø‡§ê‡§°Í£™‡•ø‡§è‡§ÄÍ£©‡•©‡•ú
    static public final List<Integer> DEVANAGARI = (0x0900..0x097F) + (0xA8E0..0xA8FF)
    // Bengali - India (92 chars) : ‡¶¢‡¶ô‡¶†‡ßÑ‡ßΩ‡¶∑‡¶ó‡¶†‡ß®‡ß£‡¶†‡ßß‡¶ù‡¶õ‡ßá‡ß∑‡¶ü‡ß∏‡ßù‡¶ò‡ß±‡ß∏‡¶£‡¶ì‡¶§‡¶æ‡¶ì‡ßá‡ß™‡ß£‡¶Ü
    static public final List<Integer> BENGALI = (0x0985..0x09FE) - [0x0984, 0x098D, 0x098E, 0x0991, 0x0992, 0x09A9, 0x09B1, 0x09B3,
                                                                    0x09B4, 0x09B5, 0x09BA, 0x09BB, 0x09C5, 0x09C6,
                                                                    0x09C9, 0x09CA, 0x09DE, 0x09E4, 0x09E5] -
        (0x09CF..0x09D6) - (0x09D8..0x09DB)
    // Gutmukhi - India (92 chars) : ‡¶¨‡¶¢‡¶ô‡¶†‡ßÑ‡ßΩ‡¶∑‡¶ó‡¶†‡ß®‡ß£‡¶†‡ßß‡¶ù‡¶õ‡ßá‡ß∑‡¶ü‡ß∏‡ßù‡¶ò‡ß±‡ß∏
    static public final List<Integer> GUTMUKHI = (0x0985..0x09FE) - [0x0984, 0x098D, 0x098E, 0x0991, 0x0992, 0x09A9, 0x09B1,
                                                                     0x09B3, 0x09B4, 0x09B5, 0x09BA, 0x09BB, 0x09C5, 0x09C6,
                                                                     0x09C9, 0x09CA, 0x09DE, 0x09E4, 0x09E5] - (0x09CF..0x09D6) - (0x09D8..0x09DB)
    // Gujarati - India (91 chars) : ‡´ê‡™ó‡´π‡´à‡´Æ‡™ù‡´å‡™ó‡´â‡™°‡´≠‡´°‡™¨‡´†‡´™‡´∞‡™¨‡™æ‡´£‡™ó‡™è‡™æ‡´©‡™¢‡´¢‡´Ä‡´Ä‡´ß‡™§‡™ø‡™ù
    static public final List<Integer> GUJARATI = (0x0A81..0x0AFF) - [0x0A84, 0x0A8E, 0x0A92, 0x0AA9, 0x0AB1, 0x0AB4, 0x0ABA, 0x0ABB,
                                                                     0x0AC6, 0x0ACA, 0x0ACE, 0x0ACF, 0x0AE4, 0x0AE5] -
        (0x0AD1..0x0ADF) - (0x0AF2..0x0AF8)
    // Oriya - India (91 chars) : ‡¨õ‡≠ù‡¨ô‡≠±‡≠ç‡≠≠‡¨ü‡≠ó‡¨ô‡≠ï‡¨£‡≠¨‡≠†‡¨Æ‡≠ü‡≠©‡≠Ø‡¨Æ‡≠Ä‡≠¢‡¨ô‡¨ê
    static public final List<Integer> ORIYA = (0x0B01..0x0B77) - [0x0B04, 0x0B0D, 0x0B0E, 0x0B11, 0x0B12, 0x0B29, 0x0B31, 0x0B34,
                                                                  0x0B3A, 0x0B3B, 0x0B45, 0x0B46, 0x0B49, 0x0B4A, 0x0B5E, 0x0B64, 0x0B65] -
        (0x0B4E..0x0B54) - (0x0B58..0x0B5B)
    // Tamil - India (76 chars) : ‡Ø∂‡Øà‡Øµ‡Øê‡Æô‡Øã‡Øê‡ØÆ‡Æé‡ØÅ‡Øß‡Æê‡Ø∞‡Æ≥‡Æü
    static public final List<Integer> TAMIL = (0x0B82..0x0BFA) - [0x0B84, 0x0B91, 0x0B9B, 0x0B9D, 0x0BC9, 0x0BCE, 0x0BCF] -
        (0x0B8B..0x0B8D) - (0x0B96..0x0B98) - (0x0BA0..0x0BA2) -
        (0x0BA5..0x0BA7) - (0x0BAB..0x0BAD) - (0x0BC3..0x0BC5) -
        (0x0BD1..0x0BD6) - (0x0BD8..0x0BE5)
    // Telegu - India (99 chars) : ‡∞§‡∞é‡±π‡∞°‡±≠‡±∑‡∞Ü‡±á‡±æ‡±∫‡∞ß‡∞ñ‡±¶‡±Ω‡±Ñ‡±®‡±∑‡±ä‡±®‡∞ô‡±á‡±Ñ‡±´‡±∫‡±ã‡∞ã‡±∫‡±á‡∞∞‡∞∏‡±∏‡∞Ç‡∞¶
    static public final List<Integer> TELEGU = (0x0C00..0x0C7F) - [0x0C0D, 0x0C11, 0x0C29, 0x0C3A, 0x0C3B, 0x0C3C, 0x0C45, 0x0C49,
                                                                   0x0C57, 0x0C64, 0x0C65, 0x0C70] -
        (0x0C4E..0x0C54) - (0x0C5B..0x0C5F) - (0x0C72..0x0C76)
    // Kannada - India (96 chars) : ‡≤µ‡≥ñ‡≥´‡≥Ä‡≤î‡≥Å‡≤•‡≤≥‡≤í‡≥¢‡≥±‡≤û‡≥£‡≤†‡≤ï‡≤å‡≥û‡≤î‡≤®‡≤Ñ‡≤Ö‡≥É‡≤û‡≥Æ‡≤ó‡≥¶‡≥ß‡≥Ñ‡≤õ‡≥ä‡≥ï‡≥é‡≤±‡≤†‡≤∂
    static public final List<Integer> KANNADA = (0x0C80..0x0CF2) - [0x0C8D, 0x0C91, 0x0CA9, 0x0CB4, 0x0CBA, 0x0CBB, 0x0CC5, 0x0CC9,
                                                                    0x0CDF, 0x0CE4, 0x0CE5, 0x0CF0] - (0x0CD7..0x0CDD)
    // Malayam (118 chars) : ‡µô‡µ≤‡¥•‡¥™‡µØ‡¥Ç‡¥¢‡¥É‡¥â‡µß‡¥å‡¥¶‡µ¨‡µè‡¥¥‡µù‡¥´‡µ†‡¥Ü‡¥æ‡µ±‡µÆ‡µû‡¥°‡µá‡µ≠‡µß‡¥û‡¥ò‡¥´‡¥°‡µû
    static public final List<Integer> MALAYAM = (0x0D00..0x0D7F) - [0x0D0D, 0x0D11, 0x0D45, 0x0D49, 0x0D64, 0x0D65] - (0x0D50..0x0D53)
    // Sinhala (94 chars) : ‡∂±‡∑ò‡∂≠‡∑Ü‡∂¶‡∂∫‡∂±‡∑ä‡∑≤‡∂π‡∑õ‡∂Ö‡∂ï‡∂Æ‡∂ê‡∑´‡∑¨‡∂£‡∂§‡∂µ‡∂™‡∑©‡∂µ‡∑ü‡∑Ø
    static public final List<Integer> SINHALA = (0x0D81..0x0DF4) - [0x0D84, 0x0DB2, 0x0DBC, 0x0DBE, 0x0DBF, 0x0DD5, 0x0DD7, 0x0DF0, 0x0DF1] -
        (0x0D97..0x0D99) - (0x0DCB..0x0DCE) - (0x0DE0..0x0DE5)
    // Thai (87 chars) : ‡∏é‡∏Å‡∏∂‡πì‡∏ø‡πë‡πã‡∏ô‡∏Ø‡∏ò‡∏≥‡∏ì‡πÄ‡∏ê‡∏é‡∏ç‡∏ñ‡πö‡πó‡∏í‡∏â‡πå‡∏ä‡∏©
    static public final List<Integer> THAI = (0x0E01..0x0E5B) - (0x0E3B..0x0E3E)
    // Tai Viet (72 chars) : Í™àÍ™ÅÍ™óÍ™§Í™äÍ™∫Í™πÍ™ìÍ™éÍ™™Í™∫Í™ßÍ™∫Í™¢Í™µÍ™©Í™úÍ™•Í™ßÍ™∫Í´õÍ™πÍ™ßÍ´úÍ™ìÍ™¨Í´Ä
    static public final List<Integer> TAI_VIET = (0xAA80..0xAAC2) + (0xAADB..0xAADF)
    // Lao (79 chars) : ‡∫î‡∫î‡ªë‡ªú‡∫ö‡∫∫‡∫•‡∫∂‡∫à‡∫û‡ªà‡∫Ø‡ªÅ‡∫º‡∫â‡∫Ü‡∫µ‡ªü‡∫ú‡∫≥
    static public final List<Integer> LAO = (0x0E81..0x0EDF) - [0x0E83, 0x0E85, 0x0E8B, 0x0EA4, 0x0EA6, 0x0EA8, 0x0EA9, 0x0EAC, 0x0EBE, 0x0EBF,
                                                                0x0EC5, 0x0EC6, 0x0ECE, 0x0ECF, 0x0EDA, 0x0EDB]

    // Tibetan (213 chars) : ‡º≠‡æØ‡ºÖ‡øà‡øá‡Ω∏‡Ω©‡æ±‡ºÉ‡Ωø‡ΩÖ‡æ£‡æá‡ºë‡Ω∏‡Ωí
    static public final List<Integer> TIBETAN = (0x0F00..0x0FDA) - (0x0F6D..0x0F70) - [0x0F98, 0x0FBD]
    // Myanmar (223 chars) : ·ÇúÍß´·ÅΩÍ©¶Íß≠·ÅÖ·Åâ·Äí·ÇäÍ©™Í©≥·Å∂Íßª·Å∞·Åä·Å¢·ÇàÍß∑·Çí·Çâ·Åá
    static public final List<Integer> MYANMAR = (0x1000..0x109F) + (0xA9E0..0xA9FE) + (0xAA60..0xAA7F)
    // Georgian (174 chars) : ·≤¥·≤ì·Éó·Éï‚¥é·É¢·Ç©·≤†·Ç§·≤ò·Éª·Éú·≤π‚¥í·Ç©·Éí·≤∫‚¥ù‚¥í·≤°·Ç∫·≤´·≤™·É±
    static public final List<Integer> GEORGIAN = (0x10A0..0x10FF) + (0x1C90..0x1CBF) - [0x10C6, 0x10CE, 0x10CF, 0x1CBB, 0x1CBC] -
        (0x10C8..0x10CC) + (0x2D00..0x2D25) + [0x2D27, 0x2D2D]
    // Ethiopic (496 chars) : ·âî·éã·âò·ãπ‚∑â·à©·åª‚∂ê·å°·ã†·ä†·åê·ç∞·âÅ·çµ
    static public final List<Integer> ETHIOPIC = (0x1200..0x1399) - [0x1249, 0x124E, 0x124F, 0x1257, 0x1259, 0x125E, 0x125F,
                                                                     0x1289, 0x128E, 0x128F, 0x12B1, 0x12B6, 0x12B7, 0x12BF,
                                                                     0x12C1, 0x12C6, 0x12C7, 0x12D7, 0x1311, 0x1316, 0x1317,
                                                                     0x135B, 0x135C] - (0x137D..0x137F) +
        (0x2D80..0x2D96) + (0x2DA0..0x2DDE) - [0x2DA7, 0x2DAF, 0x2DB7, 0x2DBF,
                                               0x2DC7, 0x2DCF, 0x2DD7] +
        (0xAB01..0xAB16) - [0xAB07, 0xAB08, 0xAB0F, 0xAB10, 0xAB27] + (0xAB20..0xAB2E)
    // Cherokee (172 chars) : ·èÉÍÆº·èûÍÆ°Í≠Ω·èäÍÆÖÍÆÇÍÆÆ·èÇÍÆé·èª·éπÍÆÄÍ≠ΩÍÆîÍÆï·èòÍÆì·èÉÍÆõ·è°ÍÆæ·é¶ÍÆá
    static public final List<Integer> CHEROKEE = (0x13A0..0x13FD) - [0x13F6, 0x13F7] + (0xAB70..0xABBF)
    // Unified Canadian Aborigine Syllabics (710 chars) : ·ñ∫·ìΩ·î¥·ï™·òè·ëü·ñπ·ñ∑·ìß·êº·ë∏·ñ≠·ñç·¢µ·êü·£Ç·ë∂·êæ·ôÜ·î≤·î£·¢µ·óß·ò´·êè
    static public final List<Integer> UCAS = (0x1400..0x167F) + (0x18B0..0x18F5)
    // OGHAM (29 chars) : ·öô·öì·öã·öí·öò·öú·öó·öó·öì·öî·öî·öç·öõ·öã·öï·öë·öÇ·öí
    static public final List<Integer> OGHAM = (0x1680..0x169C)
    // Runic (89 chars) : ·öµ·õù·õ∂·õØ·õ±·öß·ö¥·õ¶·öπ·õÇ·õç·õõ·õ´·õØ·öÆ·öº·ö§·ö∂·õÖ·õ™·õà·öπ·öÆ·õò·ö°·ö∞·ö†·õö·õÑ·õò·ö†·õî·õ©
    static public final List<Integer> RUNIC = (0x16A0..0x16F8)
    // Tagalog - Philippines (22 chars) [**] : ·úÄ·úã·úà·úã·úÖ·úÅ·úé·úè·úê·úê·úî·ú∂·úã·úå·úë·úµ·úà·úÑ·úì·úë·úÅ·úã·ú∂·úÑ·úí·úÅ·úÖ·úì·úé·úâ·úã
    static public final List<Integer> TAGALOG = (0x1700..0x1714) + [0x1735, 0x1736] - [0x170D]
    // (23 chars) : ·ú¶·ú¨·ú™·ú®·ú¶·ú§·ú†·ú≠·ú¶·ú†·úß·úÆ·ú¨·ú¶·ú∂·ú£·ú≤·ú•·ú≥·úØ·úß·ú¥
    static public final List<Integer> HANUNOO = (0x1720..0x1736)
    // (20 chars) : ·ùë·ùÑ·ùç·ùå·ùç·ùÖ·ùÑ·ùà·ùí·ùè·ùé·ùä·ùé·ùã·ùì·ùé·ùÖ·ùÜ·ùá·ùà
    static public final List<Integer> BUHID = (0x1740..0x1753)
    // (18 chars) : [**] ·ù™·ù©·ù≠·ù∞·ù£·ù¶·ù•·ù¶·ù≤·ù©·ùß·ù≤·ù†·ù™·ù∞·ù∞·ùØ·ù¢·ù•·ù©·ù¶·ù®·ù¨·ù®·ù∞·ù≠·ù•·ùß·ù†·ù≠·ùØ·ù™·ù≤·ù§·ù†·ù£·ù§·ù¢·ù¨·ù≠·ù£·ù£·ù©·ù†·ùÆ
    static public final List<Integer> TAGBANWA = (0x1760..0x1773) - [0x1773, 0x1771]
    // (144 chars) : ·ûû·ûâ·ûΩ·ß±·ß°·ßß·û§·ßΩ·ü≤·ûë·û®·ûª·û¨·ü¢·ß¨·ûÖ·ü§
    static public final List<Integer> KHMER = (0x1780..0x17F9) + (0x19E0..0x19FF) - [0x17B4, 0x17B5, 0x17DE, 0x17DF] - (0x17EA..0x17EF)
    // (153 chars) : ·†Ö·†Æ·¢ë·°â·¢†·†ª·¢â·¢¶·¢ô·°è·°∏·°Ä·¢ã·†©·°≠·†à·°Ñ·¢™·†¢·†≤·°Ä·°ô·¢â·¢ó·¢Ä·†±·°ö·¢ù·¢¶·¢í
    static public final List<Integer> MONGOLIAN = (0x1800..0x18AA) - (0x180B..0x180F) - (0x181A..0x181F) - (0x1879..0x187F)
    // SMP: + (0x11660..0x1166C)
    // (68 chars) : ·•â·•Ä·§ã·§â·§ö·§õ·§í·§Ä·§í·§®·§õ·§Ç·§Ç·§õ·§∞·•Ä·§á·§©·§ù·§∏·•ç·§¥·§à·§ã·§¥·§ñ·•ä
    static public final List<Integer> LIMBU = (0x1900..0x194F) - [0x191F] - (0x192C..0x192F) - (0x193C..0x193F) - (0x1941..0x1943)
    // Taile / new Taile (118 chars) : ·•ú·¶Å·ßÉ·¶®·¶è·¶∂·¶Ü·¶π·•ñ·¶ô·ßà·ßÖ·¶∑·•±·¶°·ßÑ·¶æ·•¨·•¶·¶Ü·•±
    static public final List<Integer> TAILE = (0x1950..0x19DF) - [0x196E, 0x196F] - (0x1975..0x197F) -
        (0x19AC..0x19AF) - (0x19CA..0x19CF) - (0x19DB..0x19DD)
    // (30 chars) : ·®ã·®á·®É·®Ä·®î·®î·®û·®é·®Ç·®Å·®é·®î·®é·®à·®Ü·®ü·®ô·®á·®ê·®ò
    static public final List<Integer> BUGINESE = (0x1A00..0x1A1F) - [0x1A1C, 0x1A1D]
    // Tai Tham (127 chars) : ·™Å·©ë·©Å·©•·©á·©≤·™â·©≤·®°·©ß·©•·™†·™á·©ë·®π·®∫·©Ä·©ñ·©ò·©à·©£·™É·©ù·©ï
    static public final List<Integer> TAI_THAM = (0x1A20..0x1AAD) - [0x1A5F, 0x1A7D, 0x1A7E] - (0x1A8A..0x1A8F) - (0x1A9A..0x1A9F)
    // (121 chars) : ·≠•·¨ô·¨é·≠ô·¨ô·≠ñ·¨∫·≠õ·¨Ç·≠∑·¨§·¨°·≠π·¨¢·¨Ä
    static public final List<Integer> BALINESE = (0x1B00..0x1B7C) - (0x1B4C..0x1B4F)
    // (72 chars) : ·Æ∫·Æπ·Æì·Æé·Æ™·Æ∫·Æß·Æ∫·Æ¢·Æµ·Æ©·Æú·Æ•·Æß·Æ∫·≥É·Æπ·Æß·≥Ñ·Æì·Æ¨·≥Ä·ÆÖ·Æô·Æª·ÆÖ
    static public final List<Integer> SUNDANESE = (0x1B80..0x1BBF) + (0x1CC0..0x1CC7)
    // (56 chars) : ·Øè·Øò·Ø•·Øü·Øë·Øõ·Ø§·Øç·Øß·Øê·Øê·Øó·Ø†·Ø¶·Ø©·ØÅ·Ø´·Øâ·Ø´·Øê·Øá·Ø¢·Ø´·Øº·ØÖ
    static public final List<Integer> BATAK = (0x1BC0..0x1BFF) - (0x1BF4..0x1BFB)
    // (74 chars) : ·∞ò·∞ø·∞õ·∞¢·±Ñ·∞ü·∞å·∞à·∞É·∞ì·∞¨·∞ø·∞ù·±É·∞Å·±Ö·∞æ·∞ë·±à·∞™·∞ø·∞∂·∞æ·∞£·∞õ·∞ã·±Å·∞®·∞¨
    static public final List<Integer> LEPCHA = (0x1C00..0x1C4F) - (0x1C38..0x1C3A) - (0x1C4A..0x1C4C)
    // OL CHIKI (48 chars) : ·±ô·±ê·±¶·±§·±´·±π·±ë·±ü·±†·±ô·±∏·±í·±©·±õ·±†·±≥·±º·±ñ·±î·±Ø·±¢·±≤·±Ω·±°·±¢·±ú·±¶·±≥·±¢·±º·±ò·±¥·±ê
    static public final List<Integer> OL_CHIKI = (0x1C50..0x1C7F)
    // (42 chars) : ·≥µ·≥§·≥±·≥≤·≥£·≥ù·≥©·≥≤·≥ó·≥ó·≥ï·≥ö·≥•·≥≤·≥≠·≥ù·≥î·≥ê·≥©·≥†·≥ù·≥ú·≥©·≥¨·≥ú·≥°·≥´·≥±·≥û·≥¢·≥õ·≥≥·≥π·≥ù·≥©·≥∑·≥®·≥±·≥∂
    static public final List<Integer> VEDIC = (0x1CD0..0x1CF9)
    // (94 chars) : ‚∞°‚∞µ‚∞¨‚±Ç‚±ú‚∞¥‚±ç‚∞É‚∞ì‚∞©‚∞é‚±ó‚±ò‚∞û‚∞ü‚∞∞‚∞•‚±ï‚∞∞‚±ë‚±õ‚∞ã‚∞õ‚∞´‚∞∫‚∞ß
    static public final List<Integer> GLAGOLITIC = (0x2C00..0x2C5E) - [0x2C2F]
    // (123 chars) : ‚≤Ñ‚≤ô‚≤£‚≤ï‚≤º‚≥≥‚≥ã‚≤Ñ‚≤ú‚≥∫‚≥≠‚≤®‚≤®‚≤∂‚≥ê‚≥é‚≤Ñ‚≤∂‚≥ã‚≤Ä‚≥â‚≥ë‚≤É‚≥∞‚≥î‚≥Ω‚≤ª‚≤ô
    static public final List<Integer> COPTIC = (0x2C80..0x2CF3) + (0x2CF9..0x2CFF) //SMP: + (0x102E0..0x102FB)
    // (59 chars) : ‚µõ‚µò‚¥∫‚µø‚µû‚¥æ‚µò‚µ†‚µò‚µÉ‚µ¢‚µë‚¥Ω‚µø‚¥∫‚¥ª‚µâ‚¥∑‚µú‚¥¥‚µç‚µò‚µé‚µò‚µú‚µü‚¥∞‚¥≥‚µ£‚µÜ‚¥∑
    static public final List<Integer> TIFINAGH = (0x2D30..0x2D67) + [0x2D6F, 0x2D70, 0x2D7F]
    // (329 chars) : ‚ºö‚º®‚æ©‚æç‚∫≤‚øà‚ªÜ‚∫ª‚º≠‚∫¨‚æù‚ªñ‚ºï‚∫Ñ‚øÄ‚º®
    static public final List<Integer> RADICALS = (0x2E80..0x2EF3) - [0x2E9A] + (0x2F00..0x2FD5)
    // (71 chars) : „Ñ®„Ü±„Ü¥„Ñé„Ñ¢„Ñ¶„Üπ„Ü°„Ñà„Ü∞„Ñ°„Ü∫„Ñç„Ü£„Ñì„ÑÆ
    static public final List<Integer> BOPOMOFO = (0x3105..0x312F) + (0x31A0..0x31BB)
    // Hangul (666 chars) : Ìû∫Ìüì·Öπ„âÜÌüÑ„âøÍ•µ·Üà·Üë„â≠„äê„äØ„â∑„àÑ„âæ·á©„àõ
    static public final List<Integer> HANGUL = (0x1100..0x11FF) + (0x3131..0x318E) - [0x3164, 0x321F] + (0x3200..0x3250) +
        (0x3260..0x32B0) + (0xA960..0xA97C) + (0xD7B0..0xD7C6) + (0xD7CB..0xD7FB) +
        (0xFFA1..0xFFDC) - [0xFFBF, 0xFFC0, 0xFFC0, 0xFFC8, 0xFFC9, 0xFFD8, 0xFFD9] //Half witdh
    // Chinese (inc. Japanese Kanji, 27,558 chars) : Á≠•Ë≤¥Á±ô„óßÁÜíÈÆº‰à•ÈßäËôπËí§ÂÜΩ„¨¨
    static public final List<Integer> HANZU = (0x3400..0x4DB5) + (0x4E00..0x9FEF)
    // (879 chars) : Ô¶â„éπÔßπÔ•áÔ•≠Ôß•„åíÔ™Å„é§„ãÇ„ãÜÔ§å„ãî
    static public final List<Integer> IDEOGRAPHIC = (0x3190..0x319F) + (0x31C0..0x31E3) + (0x32C0..0x33FF) + (0xA700..0xA721) +
        (0xE801..0xE805) + (0xF900..0xFACE) + (0xFAD2..0xFAD4) + [0xFAD8, 0xFAD9]
    // Full Width Numbers (10 chars) : ÔºñÔºòÔºëÔºóÔºìÔºïÔºïÔºíÔºêÔºïÔºòÔºïÔºêÔºóÔºë
    static public final List<Integer> FW_NUM = (0xFF10..0xFF19)
    // (26 chars) : ÔΩÜÔΩçÔΩãÔΩöÔΩÉÔΩâÔΩèÔΩÜÔΩóÔΩÇÔΩóÔΩà
    static public final List<Integer> FW_LOW = (0xFF41..0xFF5A)
    // (26 chars) : Ôº≤Ôº∏Ôº°Ôº¶Ôº≠Ôº´Ôº∫Ôº£Ôº©ÔºØÔº¶Ôº∑
    static public final List<Integer> FW_UP = (0xFF21..0xFF3A)
    // (103 chars) : ÔºñÔΩêÔºµÔºÆÔºëÔº©ÔºÖÔΩÅÔº¢ÔΩêÔºùÔø•Ôº¨ÔºùÔº∑Ôº¥
    static public final List<Integer> FULL_WIDTH = (0xFF01..0xFF60) + (0xFFE0..0xFFE6)
    // Korean (11,172 chars) : ÍπÄÎÑæÎîìÎ¨°Ïå∑ÌîëÏΩÅÏâüÎÄ∂ÏõûÌàôÏì≠ÎÜ≠Îù†ÏÇö
    static public final List<Integer> KOREAN = (0xAC00..0xD7A3)
    // Hiragana (102 chars) : „ÇÅ„Åå„Å©„Å®„ÇÑ„Çê„Åì„Å∑„Çä„Åê„Å©„Å±„Å´„áπ
    static public final List<Integer> HIRAGANA = (0x31F0..0x31FF) + (0x3041..0x3096)
    // Katakana (84 chars) : „Éö„Çæ„Ç°„ÇØ„Éì„É¥„ÉÜ„Ç¥„Ç™„ÉÆ„Éõ„Éá„Ç±„Ç∞
    static public final List<Integer> KATAKANA = (0x30A1..0x30F4)
    // (63 chars) : ÔæäÔæÉÔΩ®ÔæîÔΩπÔæõÔæûÔæÅÔΩ£ÔæõÔΩøÔΩ•ÔæÜÔæêÔæàÔæåÔæáÔΩßÔæãÔΩΩÔæíÔæù
    static public final List<Integer> HW_KATAKANA = (0xFF61..0xFF9F)
    // (1223 chars) : ÍáïÍéßÍÇæÍà≥Íè®ÍÜµÍÄòÍàÜÍç®ÍÄáÍëéÍê°ÍÅ•ÍÄßÍÜßÍÅ¨ÍÅí
    static public final List<Integer> YI_SYLLABLE = (0xA000..0xA4C6)
    // (48 chars) : Íì∫Íì¥Íì´Íì™Íì∑ÍìúÍìôÍìêÍì¶Íì§Íì´ÍìπÍìëÍìüÍì†ÍìôÍì∏ÍìíÍì©ÍìõÍì†
    static public final List<Integer> LISU = (0xA4D0..0xA4FF)
    // (300 chars) : ÍóîÍñ§ÍîÇÍîÆÍò§ÍòãÍï°Íó≤Íï†ÍîòÍïÆÍî¥ÍñæÍóòÍîåÍîë
    static public final List<Integer> VAI = (0xA500..0xA62B)
    // (88 chars) : ÍöøÍõõÍõÑÍõ∑ÍõßÍõãÍõöÍõ´Íõ°ÍõáÍõÉÍö∞ÍõòÍõ∂ÍõàÍõ¨ÍößÍõ∞Íö™Íõ±Íö¥
    static public final List<Integer> BAMUM = (0xA6A0..0xA6F7)
    // (45 chars) [**] : Í†çÍ†ïÍ†äÍ†ìÍ†ÜÍ†àÍ†¶Í†óÍ†êÍ†•Í†ãÍ†®Í†éÍ†áÍ†ôÍ†ßÍ†ñÍ†°Í†¢Í†äÍ†üÍ†ÉÍ†íÍ†íÍ†ëÍ†àÍ†ïÍ†°Í†òÍ†óÍ†•Í†âÍ†î
    static public final List<Integer> SYLOTI = (0xA800..0xA82C)
    // (56 chars) : Í°üÍ°ëÍ°õÍ°§Í°çÍ°ßÍ°êÍ°êÍ°óÍ°†Í°¶Í°©Í°ÅÍ°´Í°âÍ°´Í°êÍ°áÍ°¢Í°´Í°¥Í°ÖÍ°•Í°çÍ°îÍ°ãÍ°¢Í°±
    static public final List<Integer> PHAGS_PA = (0xA840..0xA877)
    // (82 chars) : Í¢©Í¢¶Í¢óÍ¢ÑÍ¢æÍ¢∞Í¢øÍ¢çÍ¢éÍ¢éÍ¢ëÍ¢∑Í¢úÍ¢òÍ¢ΩÍ¢¶Í¢¥Í¢èÍ¢™
    static public final List<Integer> SAURASHTRA = (0xA880..0xA8C5) + (0xA8CE..0xA8D9)
    // (48 chars) : Í§ùÍ§èÍ§éÍ§¨Í§™Í§§Í§õÍ§öÍ§ßÍ§åÍ§âÍ§ÄÍ§ñÍ§îÍ§õÍ§©Í§ÅÍ§èÍ§êÍ§âÍ§®Í§ÇÍ§ôÍ§ãÍ§êÍ§£Í§¨Í§ÜÍ§ÑÍ§üÍ§í
    static public final List<Integer> KAYAH = (0xA900..0xA92F)
    // (37 chars) : Í§µÍ•áÍ•àÍ§∏Í•ëÍ•ÑÍ§øÍ•ÅÍ•éÍ§∑Í§æÍ•ÖÍ•äÍ§∏Í•íÍ§ºÍ•ìÍ•åÍ§≥Í•êÍ§∑Í•çÍ§∞Í•Ä
    static public final List<Integer> REJANG = (0xA930..0xA953) + [0xA95F]
    // (91 chars) : Í¶òÍßÑÍßîÍ¶ïÍ¶æÍ¶àÍßÖÍ¶ïÍßÉÍ¶ìÍßïÍ¶æÍßëÍ¶ô
    static public final List<Integer> JAVA = (0xA980..0xA9DF) - [0xA9CE] - (0xA9DA..0xA9DD)
    // (83 chars) : Í®ÜÍ©ÅÍ®ÉÍ®•Í®ÅÍ®áÍ©âÍ©ìÍ®´Í®ôÍ©ôÍ©êÍ®©Í©ñÍ®≠Í®åÍ®≤
    static public final List<Integer> CHAM = (0xAA00..0xAA36) + (0xAA40..0xAA5F) - [0xAA4E, 0xAA4F, 0xAA5A, 0xAA5B]
    // (79 chars) : ÍØÄÍ´®ÍØúÍ´≠ÍØ∏ÍØÇÍ´´ÍØßÍ´≠ÍØ∏ÍØ£ÍØ§Í´¶ÍØêÍØêÍ´≤ÍØ∂ÍØñÍØ®Í´†ÍØ¶ÍØÖÍØöÍØ≠Í´£Í´´ÍØ©ÍØÜÍØÉÍ´¶
    static public final List<Integer> MEETEI = (0xAAE0..0xAAF6) + (0xABC0..0xABF9) - [0xABEE, 0xABEF]
    // Braille (255 chars) : ‚°ü‚°Ç‚£≥‚¢õ‚¢ñ‚£ó‚†ø‚£ø‚¢ê‚¢µ‚¢Ü‚£¥‚†Ç‚¢ä‚°ô‚°ú‚°Å‚¢æ‚£ì‚£ô‚£õ‚°Æ‚¢∫‚°®
    static public final List<Integer> BRAILLE = (0x2801..0x28FF)
    // Superscript (14 chars) : ‚Å∏‚Åæ‚Å∏‚Å∫‚Åø‚Å∏‚Å∏‚Åº‚Å∑‚ÅΩ‚Å∏‚Å∑‚Åæ‚Å∞‚Åπ‚Å∫‚Å∑
    static public final List<Integer> SUPERSCRIPT = [0x2070, 0x2071] + (0x2074..0x207F)
    // (28 chars) : ‚Çã‚Çï‚Çë‚ÇÇ‚Çí‚Çá‚Çô‚Çé‚Çè‚ÇÇ‚ÇÖ‚Çè‚Çò‚Çè
    static public final List<Integer> SUBSCRIPT = (0x2080..0x209C) - [0x208F]
    // (32 chars) : ‚Ç§‚Çπ‚Çπ‚Ç§‚Ç¨‚Ç¥‚Ç¨‚Ç¥‚Çπ‚Çº‚ÇΩ‚Ç≥‚Çª‚Ç¶‚Çº‚Ç°‚Ç∞‚Ç£‚Çß
    static public final List<Integer> CURRENCY = (0x20A0..0x20BF)
    // (2552 chars) : ‚ä∞‚Æ´‚öí‚óò‚ãì‚™≤‚õ±‚èä‚úç‚Öµ‚üÑ
    static public final List<Integer> SYMBOLS = (0x2010..0x2027) + [0x203E, 0x2043, 0x20DB, 0x20DC, 0x20E6, 0x20E8] + (0x2030..0x205E) +
        (0x20D0..0x20F0) + (0x2100..0x218B) + (0x2190..0x2426) + (0x2440..0x244A) +
        (0x25A1..0x2775) + (0x2794..0x27FF) + (0x2900..0x2BFF) - [0x2B74, 0x2B75, 0x2B96] +
        (0x2E00..0x2E52) + (0x2FF0..0x2FFB) + (0x3001..0x303F) + (0x3099..0x30A0) +
        (0xA830..0xA839) + (0xAB66..0xAB6B) + [0xE83A] + (0xFB00..0xFB08) + (0xFB10..0xFB12) +
        (0xFE10..0xFE19) + (0xFE20..0xFE6B) - [0xFE53, 0xFE67] + (0xFFE8..0xFFEF) +
        (0xFFF9..0xFFFD)
    // Circled numbers (71 chars) : „ä±„ä≥‚ë≠„ä∫‚ûà„ä≤„âó‚ûá‚ë¶‚ìæ‚ë≤„âó‚ë•‚ë£‚ë≥‚ì∑
    //                                                  0         1-20
    static public final List<Integer> CIRCLE_NUMS = [0x24EA] + (0x2460..0x2473) +
    //       21-35              36-50         1-10 (single line) 1-10 (double line)
        (0x3251..0x325F) + (0x32B1..0x32BF) + (0x2780..0x2789) + (0x24F5..0x24FE)
    // Negative circled numbers (31 chars) : ‚ù∫‚ûì‚ì±‚ùª‚ìø‚ûã‚ù∑‚ùæ‚ì´‚ùª‚ìÆ‚ûí‚ûç‚ì±‚ì¥
    //                                                      0           1-10              11-20              1-10 colored
    static public final List<Integer> CIRCLE_NEG_NUMS =  [0x24FF] + (0x2776..0x277F) + (0x24EB..0x24F4) + (0x278A..0x2793)
    // Numbers with parenthesis (20 chars) : ‚ë¥‚ë∏‚ëæ‚ë¥‚íÅ‚íÇ‚ë∂‚íÜ‚ë∫‚ë∫‚íÑ‚ëµ‚íÉ‚íÄ‚ëΩ‚ëΩ
    static public final List<Integer> PAREN_NUMS = (0x2474..0x2487) // 1-20
    // Lowercase letters with parenthesis (26 chars) : ‚íØ‚í≤‚í©‚í∞‚íÆ‚íú‚íû‚í¥‚í≠‚í≥‚íú‚í°‚í®
    static public final List<Integer> PAREN_LOW = (0x249c..0x24B5)
    // Circled uppercase letters (26 chars) : ‚íπ‚íº‚ìç‚í∫‚í∏‚ìÄ‚ìÇ‚íæ‚í∑‚íΩ‚ìÄ‚ìÖ‚ìå‚ìä
    static public final List<Integer> CIRCLE_UP = (0x24B6..0x24CF)
    // Circled lowercase letters (26 chars) : ‚ì£‚ì¶‚ìù‚ì§‚ì¢‚ìê‚ìí‚ì®‚ì°‚ìß‚ìê‚ìï‚ìú‚ìö‚ì©
    static public final List<Integer> CIRCLE_LOW = (0x24D0..0x24E9)
    // Box drawing (128 chars) : ‚îÉ‚ïæ‚îÇ‚ïª‚ïú‚î≥‚î™‚î¥‚îµ‚ïú‚î∫‚ï¥‚îõ‚îû‚ïê‚î°‚î°‚îé‚îµ‚ïú‚îΩ‚ïò‚î≤‚î∂‚îà‚îâ‚î´‚ïó
    static public final List<Integer> BOX = (0x2500..0x257F)
    // Block drawing (33 chars) : ‚ñá‚ññ‚ñë‚ñó‚ñî‚ñÖ‚ñÄ‚ñò‚ñÅ‚ñã‚ñû‚ñã‚ñî‚ñî‚ñô‚ñè‚ñÇ‚ñÑ‚ñõ‚ñç‚ñÖ‚ñî‚ñè‚ñç‚ñï‚ñû‚ñù‚ñî‚ñå‚ñÑ‚ñÑ‚ñù‚ñÜ‚ñõ‚ñí‚ñí
    static public final List<Integer> BLOCK = (0x2580..0x25A0)
    // Hexagram (64 chars) : ‰∑Ä‰∑é‰∑∑‰∑é‰∑∏‰∑ú‰∑ô‰∑â‰∑µ‰∑™‰∑ô‰∑π‰∑∫‰∑π‰∑¶‰∑Ç‰∑º‰∑Ñ‰∑É‰∑°
    static public final List<Integer> HEXAGRAM = (0x4DC0..0x4DFF)
    // Non-displayable (use with caution) (2,048 chars)
    //static public final List<Integer> SURROGATES = (0xD800..0xDFFF) === DOESN'T ENCODE/DECODE CORRECTLY
    //Random characters which can or not display
    static public final List<Integer> PRIVATE = (0xE000..0xF8FF)
    //Any UTF8 char (65,536 chars) use with caution as many characters can not be rendered
    static public final List<Integer> UTF8 = 0x0..0xFFFF

    /* ************ COMBOS **************** */
    //0-9a-f //similar to md5, sh,a etc (but with variable length) (16 chars)
    // Sample: d86987e6f13634f4378325c8deabba
    static public final List<Integer> HASH = NUMBERS + aTof
    //0-9A-F //same as 'HASH' but uppercase (16 chars)
    // Sample: 56412AD4B5D66855E8779CE9F83AB8
    static public final List<Integer> HASH_UP = NUMBERS + AtoF
    //a-zA-Z (52 chars)
    // Sample: qzzndkvqmITTiQYYONLnOsY
    static public final List<Integer> ALPHA = LOWERCASE + UPPERCASE
    //0-9a-zA-Z (62 chars)
    // Sample: u3ngV1s3IpO4iJjkv5LRCpYjb7KV
    static public final List<Integer> ANUM = NUMBERS + LOWERCASE + UPPERCASE
    //0-9a-zA-Z=+/ (as result of Base64, etc) (64 chars)
    // Sample: +CrCsQN8peNtuta1w32V5gee=
    static public final List<Integer> BASE64 = ANUM + EQUALPLUS
    //Ascii Extended (support for accents and other common symbols) (815 chars)
    // Sample:  õ√≤√†∆ÉÕèƒî •ƒªÃ†≈Üƒ°ƒ•Ã´…ï»¥«ç»´ÃπÕÄ»∏G≈ë ïÀ©¬´aƒç√ö«òÃèÃ≥ †≈î
    static public final List<Integer> ASCII = BASIC + EXTENDED
    // Alphanumeric in a circle (154 chars)
    // Sample: ‚íª‚íª‚ìÆ‚ìî‚ìô„äΩ‚ìì‚ì∂„âü‚í∏„ä∑‚ìã„äº‚ìá„âõ‚ûç‚ìê
    static public final List<Integer> CIRCLES = CIRCLE_LOW + CIRCLE_UP + CIRCLE_NUMS + CIRCLE_NEG_NUMS
    // Japanese, Korean, Chinese (40861 chars)
    // Sample: Îàπ„çîÈπºÏÖ£ÊÄ£Ï≠ÆÁ∏ëÏìÇÊ∏ïÁ∑£‰∏öÎôöÊπäÁüäÊçü
    static public final List<Integer> CJK = RADICALS + BOPOMOFO + HANGUL + IDEOGRAPHIC + HANZU + KOREAN + HIRAGANA + KATAKANA
    // Languages from India (705 chars)
    // Sample: ‡∞é‡≠ß‡≠üÍ£æ‡•´‡ØÇ‡¨å‡≤ú‡±¨‡ßµ‡§è‡™•‡§î‡™æ‡Ø∞‡≤∂
    static public final List<Integer> INDIAN = DEVANAGARI + BENGALI + GUTMUKHI + GUJARATI + ORIYA + TAMIL + TELEGU + KANNADA
    // South-East Asia (1673 chars)
    // Sample: ·≤î‡≠±‡∏ç·Éù·≤£‡∏Ö‡∞ä‡∂±‚¥Å‡¥ê‡≥ë‡±ô‡§µ‡Ø∫‡≤Ø
    static public final List<Integer> SE_ASIA = MALAYAM + SINHALA + THAI + LAO + MYANMAR + TAI_VIET + INDIAN + GEORGIAN + BALINESE
    // Visible characters : safe option instead of UTF8 (48392 chars)
    // Sample: ËùºÍßΩ‰Öõ‡∑ëÊ°ªÈ´Ç·ÇÖÁÇô‚£æÂÇÄ„≠ßÁûâ‰∑ÑÏ´¢Î¢∞‰∂Ç„£®
    static public final List<Integer> VISIBLE = ASCII + GREEK + CYRILLIC + ARMENIAN + HEBREW + ARABIC + SYRIAC + THAANA +
        NKO + SAMARITAN + MANDAIC + INDIAN + SE_ASIA + TIBETAN + CJK + BRAILLE + SYMBOLS + HEXAGRAM - SPACE

    /*
        SMP: Supplementary Multilingual Plane
        NOTE: Be aware that the following blocks are formed with more bytes and it might require special handling
     */
    // (80 chars) : êÖ¨êÖ§êÜÑêÖáêÖâêÖ¥êÜåêÜáêÖèêÜÑêÜáêÖªêÖÉêÖóêÖîêÖ∏êÖóêÖäêÖüêÖéêÖªêÖúêÖßêÖ•êÖùêÜÖêÜÅêÖúêÖ£
    static public final List<Integer> GREEK_SMP = (0x10140..0x1018E) + (0x101A0)
    // (13 chars) : êÜöêÜôêÜòêÜúêÜëêÜíêÜõêÜõêÜëêÜìêÜñêÜêêÜíêÜñêÜïêÜîêÜòêÜúêÜñêÜîêÜêêÜòêÜöêÜêêÜêêÜõêÜì
    static public final List<Integer> ROMAN = (0x10190..0x1019C)
    // (57 chars) : êÑéêÑñêÑ±êÑ†êÑºêÑ≤êÑäêÑØêÑäêÑùêÑâêÑîêÑîêÑ¢êÑïêÑúêÑüêÑ§êÑÄêÑ∏êÑçêÑöêÑñ
    static public final List<Integer> AEGEAN = (0x10100..0x10102) + (0x10107..0x10133) + (0x10137..0x1013F)
    // (46 chars) : êáßêáôêáùêá©êá¨êá±êáºêáóêáØêáûêáòêáûêá≠êáïêá†êáîêáîêáÆêá≠êá°êáùêá•êá©êá†êá∑êáßêá±êá†êá¨êáΩêáîêá¥êá≥êáÆêá°êáö
    static public final List<Integer> PHAISTOS = (0x101D0..0x101FD)
    // (29 chars) : êäñêäñêäíêäïêäïêäåêäöêääêäîêäêêäÉêäìêäÜêäòêäèêäéêäÉêäÑêäéêäôêäéêäÖêäÉêäïêäÉêääêäçêäòêäô
    static public final List<Integer> LYCIAN = (0x10280..0x1029C)
    // (49 chars) : êä™êäßêãÖêäºêãÖêä∏êããêãÉêäøêäÆêä¥êãÇêãçêä°êãéêä†êãêêä´êä¢êäÆêäæ
    static public final List<Integer> CARIAN = (0x102A0..0x102D0)
    // (36 chars) : êåèêåìêåÉêåÜêåÑêåòêåÜêåëêåâêåîêåõêåïêå¢êåÖêåêêåÑêåÉêåìêåàêåÇêåÖêåçêåóêåôêå°
    static public final List<Integer> OLD_ITALIC = (0x10300..0x10323)
    // (30 chars) : êå≥êåΩêçÉêå≤êçáêçáêåΩêå≤êåøêçÖêçâêåøêåªêåºêåæêçà
    static public final List<Integer> GOTHIC = (0x1032D..0x1034A)
    // (43 chars) [**] : êç¢êç∞êçêêç≠êç≤êçîêç¶êç∞êçØêçüêç´êç∫êçüêç†êçöêç∞êç†êç™êç®êç®êçûêç∑êçêêçòêç•êçïêç¢êç∞êç∂êçõêç°êçòêçüêçö
    static public final List<Integer> OLD_PERMIC = (0x10350..0x1037A)
    // (31 chars) : êéôêéàêéëêéòêéúêéÄêéîêéùêéãêéòêéåêéâêéÇêéëêéíêéüêéõêéÉêéùêéÅêéõêéöêéëêééêéõêéÖêéãêéãêéçêéãêéñêéêêéáêéöêéàêéôêéî
    static public final List<Integer> UGARTIC = (0x10380..0x1039D) + [0x1039F]
    // (51 chars) : êèìêé´êèéêèïêèéêé¢êéπêé∑êéÆêé™êéøêèëêéºêéºêéπêéπêèíêèêêèîêé≥
    static public final List<Integer> OLD_PERSIAN = (0x1039F..0x103D5) - (0x103C4..0x103C7)
    // (80 chars) : êêÑêêóêêôêëÑêêåêêáêêüêêÑêêáêëãêêìêêßêê§êëàêêßêêöêêØêêûêëãêê¨êê∑êêµêê≠êêÖêêÅêê¨êê≥êêÇ
    static public final List<Integer> DESERET = (0x10400..0x1044F)
    // (48 chars) : êëªêëµêë™êë´êë∂êëùêëòêëëêëßêë•êë™êë∏êëêêëûêë°êëòêëπêëìêë®êëöêë°êë≤êëΩêëóêëïêëÆ
    static public final List<Integer> SHAVIAN = (0x10450..0x1047F)
    // (40 chars) : êíäêíÜêí©êíãêí•êíÇêíäêíòêíïêíïêíñêí†êíùêí£êíÖêíôêíôêíÑêíãêíòêíïêíóêíÅêíëêíêêíãêíéêíöêí®
    static public final List<Integer> OSMANYA = (0x10480..0x104A9) - [0x1049E,0x1049F]
    // (72 chars) : êíªêìØêì¨êìÇêíøêìüêìØêìöêìØêììêì®êìúêìçêìòêìöêìØêì∂êì¨êìöêìπêìÇêì°êìµêí¥
    static public final List<Integer> OSAGE = (0x104B0..0x104D3) + (0x104D8..0x104FB)
    // (40 chars) [**] : êîÜêîßêîãêî£êîÇêîäêîòêîïêîïêîñêîûêîùêî°êîÖêîôêîôêîÑêîãêîòêîïêîóêîÅêîëêîêêîãêîéêîöêî¶êîâêî¶êîçêîüêîïêîöêîúêîò
    static public final List<Integer> ELBASAN = (0x10500..0x10527)
    // Caucasian Albanian (53 chars) : êïöêî∞êî∑êîæêî∂êï¢êï°êïÅêîºêïÑêïçêïàêïíêïñêïèêïÅêï†êî∫êïáêïëêïÄêïÖêïòêïìêî∂êîøêïûêïØêïúêïÅêïêêïüêîªêïòêî∏êï°
    static public final List<Integer> ALBANIAN = (0x10530..0x10563) + [0x1056F]
    // (55 chars) : ê†Øê†Éê†Æê†Éê†Æê†ïê†Ñê†èê†ëê†•ê†øê†çê†òê†ñê†Çê†©ê†Øê†±ê†çê†üê†®ê†ëê†∞ê†üê†§ê†øê†ü
    static public final List<Integer> CYPRIOT = (0x10800..0x10838) - [0x10806,0x10807,0x10809,0x10836] + [0x1083C, 0x1083F]
    // Imperial Aramaic (31 chars) : ê°îê°úê°ãê°õê°åê°âê°Çê°ëê°íê°ûê°öê°Éê°úê°Åê°öê°ùê°ëê°éê°öê°Öê°ãê°ãê°çê°ãê°ôê°êê°áê°ùê°àê°òê°î
    static public final List<Integer> ARAMAIC = (0x10840..0x1085F) - [0x10856]
    // (32 chars) [**] : ê°∏ê°•ê°≠ê°µê°≠ê°µê°∏ê°Ωê°ºê°≤ê°∫ê°ßê°Ωê°†ê°±ê°¢ê°¶ê°Øê°≠ê°µê°∏ê°øê°´ê°•ê°≥ê°≠ê°∂ê°∞ê°•ê°•ê°∞ê°∂ê°≥ê°¨ê°øê°πê°±
    static public final List<Integer> PALMYRENE = (0x10860..0x1087F)
    // (40 chars) [**] : ê¢öê¢äê¢Üê¢Øê¢ãê¢´ê¢Çê¢äê¢òê¢ïê¢ïê¢ñê¢ßê¢ùê¢©ê¢Öê¢ôê¢ôê¢Ñê¢ãê¢òê¢ïê¢óê¢Åê¢ëê¢êê¢ãê¢éê¢öê¢Æê¢â
    static public final List<Integer> NABATAEAN = (0x10880..0x1089E) + (0x108A7..0x108AF)
    // (26 chars) [**] : ê£´ê£æê££ê£©ê£Øê£§ê£Ωê£†ê£Ωê£¶ê£±ê£ªê£µê£®ê£¢ê£µê£ßê£™ê£Æê£≤ê£¥ê£ºê£ªê£Æê£®ê£Øê£≠ê£´ê£∞ê£©ê£¨
    static public final List<Integer> HATRAN = (0x108E0..0x108F5) - [0x108F3] + (0x108FB..0x108FF)
    // (29 chars) : ê§Üê§òê§èê§éê§Éê§Ñê§éê§ôê§éê§Öê§Éê§ïê§Éê§äê§çê§òê§ôê§Üê§Åê§ôê§üê§Éê§çê§ìê§ãê§äê§ïê§àê§äê§Öê§Äê§âê§áê§êê§Äê§îê§âê§ãê§àê§ñ
    static public final List<Integer> PHOENICIAN = (0x10900..0x1091B) + [0x1091F]
    // (27 chars) : ê§µê§†ê§©ê§∑ê§©ê§™ê§¶ê§∑ê§Øê§∞ê§±ê§¢ê§øê§™ê§∞ê§∂ê§µê§±ê§µê§§ê§ßê§øê§±ê§©ê§µê§¥ê§øê§≥ê§°ê§†ê§¶ê§Øê§ßê§±ê§µê§™ê§´ê§¨ê§π
    static public final List<Integer> LYDIAN = (0x10920..0x10939) + [0x1093F]
    // (242 chars) Hieroglyphic : ê•¶êßÆê•¥ê§¨ê§¶êßµêßçêßøê•Øê¶°ê§¨ê¶™êßâê¶¶ê¶úê•Éêß†ê¶´êßìêßâ
    static public final List<Integer> MEROITIC = (0x10908..0x109B7) + (0x109BC..0x109FF) - [0x109D0,0x109D1]
    // (68 chars) : ê®Öê©ìê©Ñê®êê®éê®£ê®¢ê®õê®Åê®õê®Æê®¢ê®Éê®Éê®¢ê®≤ê©Ñê®åê®±ê®§ê©Äê©óê®∏ê®èê®êê®∏ê®üê©íê®Åê©Ñê®≠ê®ëê©îê®åê®•ê©à
    static public final List<Integer> KHAROSHTHI = (0x10A00..0x10A03) + [0x10A05,0x10A06] + (0x10A0C..0x10A13) +
                                                   (0x10A15..0x10A17) + (0x10A19..0x10A35) + (0x10A38..0x10A3A) +
                                                   (0x10A3F..0x10A48) + (0x10A50..0x10A58)
    // (64 chars) : ê™Åê™èê©∂ê™èê©πê™ùê™òê™àê©¥ê©´ê™òê©∏ê©ªê©∏ê©ßê™Éê©Ωê™Öê™Çê©†ê™á
    static public final List<Integer> OLD_ARABIAN = (0x10A60..0x10A9F)
    // (51 chars) : ê´êê´ëê´≥ê´¥ê´çê´Ñê´õê´òê´Æê´úê´¶ê´áê´£ê´¨ê´µê´ëê´ùê´âê´èê´†ê´ùê´¢
    static public final List<Integer> MANICHEAN = (0x10AC0..0x10AE6) + (0x10AEB..0x10AF6)
    // (61 chars) : ê¨ºê¨íê¨õê¨ûê¨çê¨áê¨∞ê¨Åê¨ëê¨µê¨òê¨™ê¨õê¨ûê¨ºê¨°ê¨™ê¨°ê¨Æ
    static public final List<Integer> AVESTAN = (0x10B00..0x10B35) + (0x10B39..0x10B3F)
    // (30 chars) [**] : ê≠ùê≠êê≠üê≠Öê≠âê≠üê≠õê≠úê≠ûê≠àê≠äê≠Üê≠Çê≠Åê≠ïê≠ïê≠üê≠èê≠Éê≠Äê≠èê≠ïê≠èê≠âê≠áê≠ûê≠öê≠Üê≠ëê≠õê≠üê≠éê≠âê≠ìê≠òê≠êê≠ûê≠ëê≠üê≠ä
    static public final List<Integer> PARTHIAN = (0x10B40..0x10B55) + (0x10B58..0x10B5F)
    // (56 chars) [**] : ê≠≤êÆéêÆ™ê≠©ê≠£êÆêêÆØê≠¶êÆåê≠´êÆëêÆëêÆ´ê≠¢ê≠®ê≠≠êÆÄê≠ØêÆàê≠ØêÆëêÆÜê≠§ê≠Øê≠ΩêÆÑê≠©êÆåêÆöêÆäê≠§ê≠∏êÆôê≠Æê≠πêÆêê≠°êÆãê≠•
    static public final List<Integer> PAHLAVI = (0x10B60..0x10B72) + (0x10B78..0x10B91) + (0x10B99..0x10B9C) + (0x10BA9..0x10BAF)
    // (73 chars) : ê∞âê±Éê∞Öê∞∂ê∞Éê∞∞ê∞¨ê∞¥ê∞Øê∞ëê∞∞ê∞ãê∞©ê∞êê∞ôê±Üê∞†ê∞∑ê∞üê∞±ê∞§ê∞§ê±Çê∞ïê∞¢ê∞®ê∞∏ê∞îê∞§ê∞ªê∞∑ê∞çê∞ªê∞æê∞π
    static public final List<Integer> OLD_TURKIC = (0x10C00..0x10C48)
    // (158 chars) : ê≤äê≥•ê≥öê¥≥ê≤ôê¥∏ê≤öê≥°ê≥ªê≤Ñê≤Ñê¥±ê≤Éê≥éê¥Öê≥ïê≥±ê≥®ê≥ïê≥ìê≤áê≥ùê≤á
    static public final List<Integer> OLD_HUNGARIAN = (0x10C80..0x10CB2) + (0x10CC0..0x10CF2) + (0x10CFA..0x10D27) + (0x10D30..0x10D39)
    // (31 chars) : êπ∫êπ±êπÆêπªêπ•êπ´êπ´êπ≠êπ´êπ∂êπ∞êπßêπ∫êπ®êππêπ¥êπ®êπ≥êπ©êπ∂êπ¶êππêπ∫êπ´êπ¢êπ≠êπ∑
    static public final List<Integer> RUMI = (0x10E60..0x10E7E)
    // (82 chars) [**] : êºåêºèêºèêºêêºæêºùêºôêΩÑêºßêºΩêºéêº≥êºòêºõêΩêêº†êΩÜêΩèêº°êºùêºÉêºΩêºµêºñêΩàêΩñêºáêº¶êºöêΩëêº•êº≥êºìêºìêº£
    static public final List<Integer> SOGDIAN = (0x10F00..0x10F27) + (0x10F30..0x10F59)
    // (109 chars) : ëÅ©ëÄøëÅñëÅÑëÄúëÄØëÅÉëÅñëÅ†ëÄ´ëÅâëÄ´ëÅØëÄ≤ëÄ∫ëÄçëÄäëÄµëÅâëÄîëÅöëÄ°ëÅÖëÅßëÄüëÄ¨ëÅßëÄØëÄÖ
    static public final List<Integer> BRAHMI = (0x11000..0x1104D) + (0x11052..0x1106F) + [0x1107F]
    // (66 chars) : ëÇ©ëÇ•ëÇâëÇµëÇßëÇøëÇõëÇ∏ëÇÑëÇ§ëÇèëÇ≥ëÇãëÇÑëÇâëÇ£ëÇÜëÇôëÇúëÇîëÇïëÇ≥ëÇ±ëÇõëÇ´ëÇ∏ëÇ¥ëÇçëÇ¥ëÇø
    static public final List<Integer> KAITHI = (0x11080..0x110C1)
    // (36 chars) [**] : ëÉïëÉ®ëÉóëÉûëÉñëÉ•ëÉ±ëÉ¢ëÉ∏ëÉíëÉ°ëÉïëÉêëÉ†ëÉôëÉìëÉíëÉöëÉ§ëÉ¶ëÉ∑ëÉêëÉ§ëÉ®ëÉìëÉçëÉπ
    static public final List<Integer> SORA_SOMPENG = [0x110CD] + (0x110D0..0x110E8) + (0x110F0..0x110F9)
    // (70 chars) : ëÑ©ëÑóëÑäëÖÜëÑØëÑàëÑâëÑπëÑ∏ëÑîëÑ±ëÖÖëÑâëÑõëÑªëÑöëÑºëÑ≤ëÑ°ëÑºëÑíëÖÇëÖÅëÑªëÑäëÑíëÑäëÑäëÑΩëÑèëÑ∑ëÑñëÑøëÑ±ëÑïëÖÑëÑ¥ëÑ¶
    static public final List<Integer> CHAKMA = (0x11100..0x11134) + (0x11136..0x11146)
    // (39 chars) [**] : ëÖ©ëÖ§ëÖ°ëÖ§ëÖ©ëÖ¨ëÖ¥ëÖ†ëÖëëÖ•ëÖ∂ëÖûëÖ±ëÖ®ëÖûëÖ≥ëÖÆëÖ£ëÖòëÖñëÖóëÖ©ëÖ©ëÖ£ëÖü
    static public final List<Integer> MAHAJANI = (0x11150..0x11176)
    // (96 chars) : ëáÉëÜ≤ëáùëÜêëáôëÜ∞ëáèëáòëÜªëÜìëÜ∫ëÜ¢ëÜ±ëÜëëáìëáüëÜùëáíëÜüëÜíëÜçëáéëÜìëÜßëÜÖëÜÑëÜºëÜùëáùëÜîëáïëáîëÜø
    static public final List<Integer> SHARADA = (0x11180..0x111DF)
    // (38 chars) : ëá≥ëá≥ëá§ëáØëá¨ëáØëáßëá§ëá®ëá≤ëá±ëáÆëá™ëáÆëá≠ëá¥ëáÆëáßëá¶ëá©ëá®
    static public final List<Integer> SHINHALA = (0x111E1..0x111F4)
    // (62 chars) : ëà¢ëàØëàßëàÜëàîëà°ëàºëàéëààëà•ëà®ëàØëàÇëàªëàâëàïëàÅëàõëà®ëà®ëà≥ëà∑ëàâëà©
    static public final List<Integer> KHOJKI = (0x11200..0x1123E) - [0x11212]
    // (38 chars) [**] : ëääëä£ëä°ëäõëäßëääëäòëäùëäçëäôëäêëäëëääëäßëä®ëäüëä¶ëäÄëäèëäñëäçëäãëäñëä°ëä•ëäÜëäùëäÑëä¢ëä°
    static public final List<Integer> MULTANI = (0x11280..0x112A9) - [0x11287,0x11289,0x1128E,0x1129E]
    // (69 chars) : ëä∂ëã•ëäºëãÄëãñëãîëãñëä∂ëãòëã∑ëãÑëä∏ëä≥ëãìëãÑëãëëä∫ëã∞ëã≥ëã∞ëã¶ëãèëãàëã∏ëã™ëãëëã•ëã∏
    static public final List<Integer> KHUDAWADI = (0x112B0..0x112EA) + (0x112F0..0x112F9)
    // (85 chars) : ëåñëåÇëåΩëç∞ëåñëååëåÜëçüëçùëç∞ëåöëå≤ëç¢ëåøëåìëçûëå¢ëçÉëååëç¥ëççëåûëç°ëåÆëçßëç¶ëåìëåßëåÅëåà
    static public final List<Integer> GRANTHA = (0x11300..0x11303) + (0x11305..0x1130C) + (0x1130F..0x11310) + (0x11313..0x11328) +
                                                (0x1132A..0x11330) + [0x11332,0x11333] + (0x11335..0x11339) + (0x1133C..0x11344) +
                                                [0x11347,0x11348,0x1134B,0x1134C,0x1134D,0x11350,0x11357] + (0x1135D..0x11363) +
                                                (0x11366..0x1136C) + (0x11370..0x11374)
    // (97 chars) : ëêàëëôëêøëêëëêìëëóëêéëê≥ëê≠ëêèëê©ëëèëêªëêöëê¨ëêºëê®ëëòëëâëêûëëêëëÖëêÆëê¢ëêáëëÄëêÅëêò
    static public final List<Integer> NEWA = (0x11400..0x11461) - [0x1145C]
    // (82 chars) : ëí®ëíßëíñëíÖëíøëí±ëíæëíåëíèëíèëíêëí∂ëíùëíôëíºëíßëíµëíéëí´ëíòëíõëìêëí†ëíæëìáëí°ëíùëíÉ
    static public final List<Integer> TIRHUTA = (0x11480..0x114C7) + (0x114D0..0x114D9)
    // (92 chars) : ëóùëóÖëóìëñâëñ±ëñ£ëñòëñëëññëñµëóùëñ®ëñèëññëóÜëóÖëññëóáëñïëñìëñ¥ëóóëñóëóñëñæëñéëóëëóñëñõ
    static public final List<Integer> SIDDHAM = (0x11580..0x115B5) + (0x115B8..0x115DD)
    // (79 chars) : ëò≠ëòëëòëëôÉëôóëòóëò∞ëò°ëò¨ëòÑëòõëò∫ëòßëò∑ëò≤ëòáëòÇëò≠ëôòëòôëò´ëòøëôíëôìëòÅëò§ëòïëò¢ëôíëôÅëôÄëòç
    static public final List<Integer> MODI = (0x11600..0x11644) + (0x11650..0x11659)
    // (67 chars) : ëöåëöåëö¢ëö§ëö©ëõÜëõÖëöèëöÖëöµëöàëöèëöÉëõÇëöÖëö≤ëöìëö≤ëö∑ëöîëööëöãëö®ëöïëö∏ëößëö∞
    static public final List<Integer> TAKRI = (0x11680..0x116B8) + (0x116C0..0x116C9)
    // (58 chars) : ëúóëúèëú∞ëú°ëúêëú∂ëúìëúéëúÑëúÉëú¢ëúèëúåëúïëúåëúåëú∫ëúòëúàëú≥ëúÇëúÇëúºëú†ëúÅëú∞ëúãëú≤
    static public final List<Integer> AHOM = (0x11700..0x1171A) + (0x1171D..0x1172B) + (0x11730..0x1173F)
    // (84 chars) : ë£ìë£øë£Ñë¢≤ë¢®ë£¨ë£õë£áë¢±ë¢Æë¢≤ë¢Æë£≤ë£ëë¢™ë¢ßë£îë£êë¢Ωë¢¢ë¢∂ë¢£ë£®ë£àë¢¨ë¢´ë£úë£≠ë¢†
    static public final List<Integer> WARANG_CITI = (0x118A0..0x118F2) + [0x118FF]
    // (72 chars) : ë®Äë®ñë®•ë®ãë®ªë®∏ë®íë®èë®´ë®ªë®¶ë®ªë®£ë®¥ë®®ë®ùë®§ë®¶ë®ªë©Çë®∏ë®¶ë©Öë®íë®≠
    static public final List<Integer> ZANABAZAR = (0x11A00..0x11A47)
    // (83 chars) : ë©óë©πë©õë™çë©ûë©≤ë™ñë™Åë©ùë™Éë©ßë©¢ë©Øë©¥ë©£ë™Äë©∑ë©êë©êë™õë©ùë©úë™ïë©¶ë™çë©¶ë©í
    static public final List<Integer> SOYOMBO = (0x11A50..0x11AA2)
    // (57 chars) : ë´≠ë´úë´∑ë´Æë´Üë´´ë´Üë´ôë´Öë´êë´êë´ûë´ëë´òë´õë´†ë´Äë´≥ë´âë´ñë´íë´¢ë´ûë´ûë´Æë´ë
    static public final List<Integer> PAU_CIN_HAU = (0x11AC0..0x11AF8)
    // (97 chars) : ë±°ë±ôë∞ùë±ûë∞ãë±•ë±Åë∞êë∞íë±£ë∞ëë∞≤ë∞¨ë∞éë∞®ë±õë∞Ωë∞ùë∞Øë∞æë∞´ë±§
    static public final List<Integer> BHAIKSUKI = (0x11C00..0x11C45) - [0x11C09,0x11C37] + (0x11C50..0x11C6C)
    // (68 chars) : ë≤Éë±¥ë≤àë±≤ë≤¶ë±ªë≤≠ë±∫ë≤Öë≤Åë≤ñë≤úë±øë≤¶ë±ºë±≤ë≤Öë±∏ë±≤ë≤ä
    static public final List<Integer> MARCHEN = (0x11C70..0x11C8F) + (0x11C92..0x11CB6) - [0x11CA8]
    // (1235 chars) : íÄ©íì≤íçúíÑÖíä†íÖ≥íÇùíÉΩíåÆíê£íÅÇíçæ
    static public final List<Integer> CUNEIFORM = (0x12000..0x12399) + (0x12400..0x12474) + (0x12480..0x12543)
    // (1071 chars) Hieroglyphic : ìÇ∑ìéÅìã§ìâóìÅæìÇûìãÆìÅ¢ìÜ≥ìáàìã∂ìèÅìäôìÉ®ìäáìÄøìèå
    static public final List<Integer> EGYPTIAN = (0x13000..0x1342E)
    // (583 chars) Hieroglyphic : îí∂îíãîî£îïíîìüîîÑîê©îê≠îí•îêñîñ•îìøîíóîòµîï¢îëõîñÇîêóîòêîë∑îôÅ
    static public final List<Integer> ANATOLIAN = (0x14400..0x14646)
    // (570 chars) : ñ¶∑ñ¶∑ñ¢çñ¢íñ†ùñ§Öñ¶ïñ†•ñ®©ñ°ññßÉñ¶çñ¢Øñ§ôñß´ñ¶òñ®≠ñ°∑ñßÜñ£Ωñ¢èñ£®
    static public final List<Integer> BAMUM_SMP = (0x16800..0x16A39)
    // (136 chars) [**] : ñ©ññ©£ñ©ûñ©èñ©õñ©Æñ©èñ©êñ©äñ©£ñ©êñ©öñ©òñ©òñ©éñ©¶ñ©Äñ©àñ©ïñ©Öñ©íñ©£ñ©©ñ©ãñ©ëñ©àñ©èñ©äñ©ïñ©®ñ©ö
    static public final List<Integer> MRO = (0x16A40..0x16A69) - [0x16A5F] + [0x16A6E,0x16A6F]
    // (142 chars) [**] : ñ´®ñ´ññ´°ñ´ôñ´§ñ´´ñ´•ñ´¥ñ´ïñ´†ñ´îñ´ìñ´£ñ´òñ´íñ´ïñ´ùñ´ßñ´©ñ´≥ñ´ìñ´ßñ´®ñ´íñ´ëñ´µñ´¥ñ´êñ´ôñ´öñ´ìñ´®ñ´úñ´ñ
    static public final List<Integer> BASSA_VAH = (0x16AD0..0x16AED) + (0x16AF0..0x16AF5)
    // (127 chars) : ñ¨îñÆãñ¨¢ñ¨Ωñ¨òñ≠øñ≠†ñ≠úñ≠´ñ¨∞ñ¨†ñ≠Öñ¨¶ñ≠ùñ≠≥ñ≠ùñ¨Äñ≠ëñ≠ÖñÆÉñ≠±ñ¨∞ñ¨òñ¨õñ¨°ñ¨∑ñ¨πñ¨©ñ≠Éñ≠≠ñ¨ºñ¨¥
    static public final List<Integer> PAHAWH_HMONG = (0x16B00..0x16B45) + (0x16B50..0x16B77) - [0x16B5A,0x16B62] + (0x16B7D..0x16B8F)
    // (149 chars) : ñºáñºúñΩ≤ñΩ≤ñæúñΩëñº∑ñºπñΩ≠ñΩÜñº±ñº©ñæùñº∑ñΩÜñæÇñº¶ñºúñΩ≠ñæôñΩ©ñΩîñº±ñºõñΩàñΩïñΩ∞
    static public final List<Integer> MIAO = (0x16F00..0x16F4A) + (0x16F4F..0x16F87) + (0x16F8F..0x16F9F)
    // (6892 chars) : ó∏ìòè∂óúõó§≠ó∑ïóõãóûÜòãëòèÅóã©ò™âóï§óæ§òóó
    static public final List<Integer> TANGUT = [0x16FE0] + (0x17000..0x187F7) + (0x18800..0x18AF2)
    // (396 chars) [**] : õâ≠õàûõÜ§õäÄõÖ∑õà†õã∫õä™õâ∏õâíõÜèõÜπõâäõàôõÖºõàûõàñõâ¢õáØ
    static public final List<Integer> NUSHU = (0x1B170..0x1B2FB)
    // (144 chars) : õ±üõ±ºõ∞ïõ±óõ≤íõ±®õ∞¥õ±ãõ∞üõ∞àõ∞∫õ≤Äõ±ûõ±±õ∞•õ≤úõ≤Éõ∞êõ∞©õ∞∏õ∞≠õ±°õ±∂õ∞Ñõ±•
    static public final List<Integer> DUPLOYAN = (0x1BC00..0x1BC6A) + (0x1BC70..0x1BC7C) + (0x1BC80..0x1BC88) + (0x1BC90..0x1BC9F) - [0x1BCAA,0x1BCAB,0x1BC9D]
    // (549 chars) : ùà®ùÇ¨ùÜ¥ùÅ¥ùÇØùÄßùÖ¨ùÉçùàπùÅÖùáñùàæùàãùàΩùÜóùÖ£ùáåùÅ¢ùáÜùÖ§ùÖêùÖòùÄúùÉ§ùÅ∫ùÖàùÑªùÄØùÖ≠ùÖÜùÜ¢
    static public final List<Integer> MUSICAL = (0x1D000..0x1D0F5) + //Byzantine
                                                (0x1D100..0x1D1EA) - [0x1D127,0x1D128] + //General
                                                (0x1D200..0x1D245) //Greek
    // (20 chars) : ùãÆùãØùã´ùãØùã™ùã≤ùãØùã§ùãßùã¶ùã©ùã†ùã•ùã≤ùãØùã§ùã∞
    static public final List<Integer> MAYAN = (0x1D2E0..0x1D2F3)
    // (87 chars) * Similar to HEXAGRAMS : ùå¥ùçèùåªùççùçáùåôùåØùåñùå≥ùåìùå∫ùåéùååùåçùåîùçîùçìùåê
    static public final List<Integer> TAIXUANJING = (0x1D300..0x1D356)
    // (25 chars) : ùç´ùçµùç¢ùç™ùç¨ùç¥ùç∑ùçßùç®ùç©ùç∞ùçÆùç¢ùç§ùç¥ùç¢ùç∏ùç¶ùçßùç¢
    static public final List<Integer> COUNTING = (0x1D360..0x1D378)
    // (1020 chars) : ùüâùõ∏ùõûùõëùëÉùê≤ùõæùôüùî∂ùõôùóûùêéùîÉùîâùú≠ùóêùóñ
    static public final List<Integer> MATH = (0x1D400..0x1D7FF) - [0x1D6A6,0x1D6A7,0x1D7CD,0x1D7CE]
    // (38 chars) [**] : ûÄìûÄïûÄóûÄ®ûÄßûÄêûÄàûÄ†ûÄõûÄ°ûÄÑûÄãûÄ†ûÄûûÄòûÄ¶ûÄãûÄñûÄùûÄäûÄóûÄéûÄèûÄãûÄ¶ûÄ™ûÄüûÄ©ûÄÄûÄåûÄîûÄäûÄàûÄîûÄûûÄ§ûÄÜûÄùûÄÑûÄ£ûÄûûÄ£ûÄåûÄñûÄ¶ûÄ£ûÄ§ûÄåûÄüûÄîûÄÖûÄÉûÄâûÄâûÄêûÄõûÄÉûÄãûÄ£ûÄÑûÄêûÄ©ûÄÄûÄâûÄòûÄ¶ûÄçûÄßûÄõûÄÅ
    static public final List<Integer> GLAGOLITIC_SMP = (0x1E000..0x1E02A) - [0x1E007,0x1E019,0x1E01A,0x1E022,0x1E025]
    // (71 chars) [**] : ûÑüûÑÇûÖÅûÑúûÖèûÑâûÑ£ûÑèûÑªûÑúûÑÑûÑÖûÖÅûÑüûÖÜûÑ®ûÑ°ûÑîûÑñûÑÖûÖÖûÑΩûÖÄûÑïûÑî
    static public final List<Integer> NYIAKENG = (0x1E100..0x1E12C) + (0x1E130..0x1E13D) + (0x1E140..0x1E149) + [0x1E14E,0x1E14F]
    // (59 chars) : ûã™ûã©ûããûãøûãØûãèûã©ûã±ûã©ûãíûã≥ûã†ûãåûãøûããûãäûãòûãÜûã≠ûãÖûãúûã©ûãüûã©ûã≠ûãÆûãÅûãÇûã≤
    static public final List<Integer> WANCHO = (0x1E2C0..0x1E2F9) + [0x1E2FF]
    // (213 chars) : û£Äû°µû°®û¢≠û†Çû°∫û°Ñû¢üû¢Çû†êû°µû°ìû°©û†®û°πû°ªû†ëû†™û¢Éû°•û¢öû†â
    static public final List<Integer> MENDE_KIKAKUI = (0x1E800..0x1E8D6) - [0x1E8C5,0x1E8C6]
    // (88 chars) : û•üû§©û•ëû§Üû•ïû§ãû•îû§ïû§¢û•îû§±û§ìû§≤û§Ñû§Üû§òû§ßû§©û§£û•ëû§¥û•ìû§≥û§≤û§öû§™û§Äû•Ñû§∫û§±û§Åû§¢û•ü
    static public final List<Integer> ADLAM = (0x1E900..0x1E94B) + (0x1E950..0x1E959) + [0x1E95E,0x1E95F]
    // (68 chars) :           û≤Æû≤óû±ªû≤Åû±≤
    static public final List<Integer> SIYAQ = (0x1EC71..0x1ECB4)
    // (143 chars) : û∏õûπ∂û∫òû∫•û∫íû∫Øû∫¶û∫¨û∫¥û∫åûπ°û∏Æûπáû∫∑û∫ñûππûπµ
    static public final List<Integer> ARABIC_SMP = (0x1EE00..0x1EEBB) + [0x1EEF0,0x1EEF1] - [0x1EE04,0x1EE20,0x1EE23,0x1EE25,0x1EE26,
                                                                                             0x1EE28,0x1EE33,0x1EE38,0x1EE3A,0x1EE48,
                                                                                             0x1EE4A,0x1EE4C,0x1EE50,0x1EE53,0x1EE55,
                                                                                             0x1EE56,0x1EE58,0x1EE5A,0x1EE5C,0x1EE5E,
                                                                                             0x1EE60,0x1EE63,0x1EE65,0x1EE66,0x1EE6B,
                                                                                             0x1EE73,0x1EE78,0x1EE7D,0x1EE7F,0x1EE8A,
                                                                                             0x1EEA4,0x1EEAA] -
                                                    (0x1EE3C..0x1EE41) - (0x1EE43..0x1EE46) - (0x1EE9C..0x1EEA0)
    // (44 chars) : üÄîüÄçüÄõüÄèüÄ™üÄñüÄÉüÄîüÄçüÄçüÄöüÄ™üÄàüÄÖüÄôüÄá
    static public final List<Integer> MAHJONG = (0x1F000..0x1F02B)
    // (100 chars) : üÇÇüÅ∞üÅèüÅµüÅ≠üÇÄüÅ•üÄπüÅâüÄ∏üÄ±üÅ†üÅ≤üÇçüÄªüÅ±üÇíüÅåüÄªüÄ¥üÄ¥üÅºüÄ±üÅ©üÄ∏üÅêüÅ®üÅåüÄ∑
    static public final List<Integer> DOMINO = (0x1F030..0x1F093)
    // (82 chars) : üÇøüÉÖüÉìüÇπüÉ†üÉçüÉàüÇ∏üÇ•üÉ£üÉïüÉ¢üÇ¨üÇÆüÇÆüÇ≤üÉö
    static public final List<Integer> CARDS = (0x1F0A0..0x1F0F5) - [0x1F0AF,0x1F0B0,0x1F0C0,0x1F0D0]
    // (84 chars) : ü®äü®áü®¥ü®∞ü®ùü®Çü®ñü®Éü©àü®®ü®åü®ãü®ºü©çü®Äü®øü®èü®©ü®¶
    static public final List<Integer> CHESS = (0x1FA00..0x1FA53)
    // (14 chars) : ü©ßü©≠ü©ßü©©ü©¨ü©ßü©ßü©´ü©§ü©™ü©ßü©§ü©≠
    static public final List<Integer> CHESS_CH = (0x1FA60..0x1FA6D)
    // (10 chars) : üÑÖüÑÖüÑÜüÑàüÑÉüÑâüÑÖüÑáüÑáüÑÇüÑÅüÑáüÑàüÑáüÑÅüÑâüÑÉüÑÑüÑÉüÑäüÑàüÑÉüÑÖ
    static public final List<Integer> COMMA_NUM = (0x1F101..0x1F10A)
    // (26 chars) : üÑñüÑ°üÑ§üÑ¢üÑòüÑíüÑ¢üÑóüÑöüÑûüÑ£üÑ•üÑ¶üÑ§
    static public final List<Integer> PAREN_UP = (0x1F110..0x1F129)
    // (26 chars) : üÑ∫üÑ∏üÖàüÖÇüÑ∏üÖáüÑ∞üÑ¥üÑπüÑªüÑºüÑ∫üÑ¥üÖàüÑµüÑ≥üÑ±üÑ∂üÖâüÑ≤
    static public final List<Integer> SQUARE_UP = (0x1F130..0x1F149)
    // (26 chars) : üÖßüÖêüÖßüÖñüÖ°üÖ§üÖ¢üÖòüÖíüÖ¢üÖóüÖöüÖûüÖ£üÖ•üÖ¶üÖ§üÖûüÖòüÖü
    static public final List<Integer> CIRCLE_UP_NEG = (0x1F150..0x1F169)
    // (26 chars) : üÖ∏üÜáüÖ∞üÖ¥üÖπüÖªüÖºüÖ∫üÖ¥üÜàüÖµüÖ≥üÖ±üÖ∂üÜâüÖ≤üÖ∂üÖæüÖ±üÜÑüÜáüÜÄüÜÉüÜÜüÜÄ
    static public final List<Integer> SQUARE_UP_NEG = (0x1F170..0x1F189)
    // (150 chars) : ü†òü†äü†ùü°ôü†ùü¢´ü†áü†¥ü°´ü†ºü†§ü†ßü†óü¢óü†©ü¢Äü°ñü†Ωü†ãü¢üü°¥ü†øü¢ùü¢îü†ìü¢ëü°°ü°øü¢Öü†∂
    static public final List<Integer> ARROWS = (0x1F800..0x1F847) - (0x1F80C..0x1F80F) + (0x1F850..0x1F859) + (0x1F860..0x1F887) + (0x1F890..0x1F8AD) + [0x1F8B0,0x1F8B1]
    // (654 chars) : êöìüÑãüôîêôµüú∂üú©üù§üúéüô∂êõñüÑãüüÅüô¥êú¢üô™êöºüÜçüùùêúúüô∑üÖ≠üüïüÜîüúæüúá
    static public final List<Integer> SYMBOLS_SMP = (0x10600..0x10736) + (0x10740..0x10755) + (0x10760..0x10767) +
                                                    (0x1F650..0x1F67F) + // Dingbats
                                                    (0x1F700..0x1F773) + // Alchemical
                                                    (0x1F780..0x1F7D8) + // Geometric
                                                    [0x1F100] + (0x1F10B..0x1F10F) + (0x1F12A..0x1F12F) + (0x1F14A..0x1F14F) + (0x1F16A..0x1F16F) + (0x1F18A..0x1F1AD) // Assorted
    // (1325 chars) : ü•øü©≤üëôü™ûüßÑüõ°üó¶üïôü´õüóêü™µüü®üìéüîùüñòüé∏üêîü•ïüî¨üèæü´µüõ£
    static public final List<Integer> EMOJI = (0x1F300..0x1F64F) + (0x1F680..0x1F6D7) + (0x1F6E0..0x1F6EC) + (0x1F6F0..0x1F6FC) +
                                              (0x1F90C..0x1F9FF) + (0x1FA70..0x1FA7C) + (0x1FA80..0x1FA88) + (0x1FA90..0x1FABD) +
                                              (0x1FABF..0x1FAC5) + (0x1FACE..0x1FADB) + (0x1FAE0..0x1FAE8) + (0x1FAF0..0x1FAF8) +
                                              (0x1F7E0..0x1F7EB) // Geometric
    // (269 chars) : êÄ®êÄ§êÉÇêÄ≤êÇáêÉöüàòêÉêêÇ¨êÄÖüàñêÇΩêÄàêÉ•êÇ†êÇ≠êÇÆêÉ†üàñêÇªêÇãêÉõêÉ•êÅåêÄöêÉÑ
    static public final List<Integer> IDEOGRAMS = (0x10000..0x1005D) - [0x1000C,0x10027,0x1003B,0x1003E,0x1004E,0x1004F] +
                                                  (0x10080..0x100FA) + (0x1F200..0x1F202) + (0x1F210..0x1F23B) + (0x1F240..0x1F248) +
                                                  [0x1F250,0x1F251]
    // (203 chars) : ü≠ñü¨°üØàü¨åüÆøüÆµüÆéü≠°ü¨óü≠ÄüÆü
    static public final List<Integer> BLOCK_SMP = (0x1FB00..0x1FBCA)
    // (10 chars) : üØ¥üØ±üØ∂üØ∞üØµüØ∞üØ∏üØπüØ∞üØ≤üØ∏üØπüØ∏üØ±üØ≤
    static public final List<Integer> DIGITS = (0x1FBF0..0x1FBF9)


    /* ************ SMP COMBOS **************** */
    // Hieroglyphics (1896 chars) : ìã¢ìÅØìÇ±ìçûìå¥îñ•îí∫
    static public final List<Integer> HIEROGLYPHIC = EGYPTIAN + MEROITIC + ANATOLIAN
    // Lines (151 chars) : ùå≠ùççùå¥‰∑è‰∑ãùåÖùå∞ùåõùåÄùåà‰∑´ùçñùåÅùåÇ‰∑õ‰∑ñ
    static public final List<Integer> LINES_SMP = HEXAGRAM + TAIXUANJING
    // (1317 chars) : íÄäíã´íê≠íî´íåªíääíâ≤íëôíÄÇíâπ
    static public final List<Integer> WEDGE = UGARTIC + OLD_PERSIAN + CUNEIFORM
    // (68,498 chars) : „ãüËÆûü¨µÌÑáêäàÌúπüØà‚õ∑Êì∂
    static public final List<Integer> VISIBLE_SMP = VISIBLE + GREEK_SMP + ROMAN + AEGEAN + PHAISTOS + LYCIAN + CARIAN + OLD_ITALIC +
        GOTHIC + OLD_PERMIC + UGARTIC + OLD_PERSIAN + DESERET + SHAVIAN + OSMANYA + OSAGE + ELBASAN + ALBANIAN + CYPRIOT + ARAMAIC +
        PALMYRENE + NABATAEAN + HATRAN + PHOENICIAN + LYDIAN + MEROITIC + KHAROSHTHI + OLD_ARABIAN + MANICHEAN + AVESTAN + PARTHIAN +
        PAHLAVI + OLD_TURKIC + OLD_HUNGARIAN + RUMI + SOGDIAN + BRAHMI + KAITHI + SORA_SOMPENG + CHAKMA + MAHAJANI + SHARADA + SHINHALA +
        KHOJKI + MULTANI + KHUDAWADI + GRANTHA + NEWA + TIRHUTA + SIDDHAM + MODI + TAKRI + AHOM + WARANG_CITI + ZANABAZAR + SOYOMBO +
        PAU_CIN_HAU + BHAIKSUKI + MARCHEN + CUNEIFORM + EGYPTIAN + ANATOLIAN + BAMUM_SMP + MRO + BASSA_VAH + PAHAWH_HMONG + MIAO +
        TANGUT + DUPLOYAN + MUSICAL + MAYAN + TAIXUANJING + COUNTING + MATH + GLAGOLITIC_SMP + NYIAKENG + WANCHO + MENDE_KIKAKUI +
        ADLAM + SIYAQ + ARABIC_SMP + MAHJONG + DOMINO + CARDS + COMMA_NUM + PAREN_UP + SQUARE_UP + CIRCLE_UP_NEG + SQUARE_UP_NEG +
        ARROWS + SYMBOLS_SMP + EMOJI + CHESS + CHESS_CH + IDEOGRAMS + BLOCK_SMP + DIGITS

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Wrapper around a list of characters with special properties
     */
    static class CharSet {
        final private List<Integer> chars

        CharSet(Collection<Integer> chars) {
            this.chars = chars.toList().unique()
            assert length > 1 : "Charset must be at least 1 character"
        }

        int getLength() {
            return chars.size()
        }

        int getPosition(int chr) {
            return chars.toList().indexOf(chr)
        }

        int getAt(int index) {
            return chars[index]
        }

        List<Integer> getChars() {
            return chars.collect() // Create a clone of the List so we don't modify it
        }
    }

    private CharSet input
    private CharSet output
    private long seed
    /**
     * Constructor using a CharSet as input and a list as output
     * @param input
     * @param output
     * @param seed
     */
    LpCode(CharSet input, Collection<Integer> output, long seed = 0) {
        this.input = input
        this.output = new CharSet(output)
        this.seed = seed
    }
    /**
     * Constructor using a list of characters and a CharSet
     * @param input
     * @param output
     * @param seed
     */
    LpCode(Collection<Integer> input, CharSet output, long seed = 0) {
        this.input = new CharSet(input)
        this.output = output
        this.seed = seed
    }
    /**
     * Constructor using input and output as CharSet
     * @param input
     * @param output
     * @param seed
     */
    LpCode(CharSet input, CharSet output, long seed = 0) {
        this.input = input
        this.output = output
        this.seed = seed
    }
    /**
     * Constructor using two lists of characters
     * @param input
     * @param output
     * @param seed
     */
    LpCode(Collection<Integer> input = BASIC, Collection<Integer> output = ANUM, long seed = 0) {
        this.input = new CharSet(input)
        this.output = new CharSet(output)
        this.seed = seed
    }
    /**
     * Get the BigInteger from an array of characters for a specific CharSet
     * @param chars
     * @param charSet
     * @param seed
     * @return
     */
    static BigInteger toNumber(char[] chars, CharSet charSet, long seed = 0) {
        LpCode lpCode = new LpCode(charSet, charSet, seed)
        if(seed) { chars = lpCode.randomize(chars) }
        return toNum(chars, charSet)
    }
    /**
     * Get the BigInteger from an array of characters for a specific list of characters
     * @param chars
     * @param charSet
     * @param seed
     * @return
     */
    static BigInteger toNumber(char[] chars, Collection<Integer> charSet, long seed = 0) {
        return toNumber(chars, new CharSet(charSet), seed)
    }
    /**
     * Convert number to char array
     * @param number
     * @param charSet
     * @param seed
     * @return
     */
    static char[] toCharArray(BigInteger number, CharSet charSet, long seed = 0) {
        LpCode lpCode = new LpCode(charSet, charSet, seed)
        char[] chars = toStr(number, charSet)
        if(seed) { chars = lpCode.randomize(chars, true) }
        return chars
    }
    /**
     * Convert number to char array using a list of characters
     * @param number
     * @param charSet
     * @param seed
     * @return
     */
    static char[] toCharArray(BigInteger number, Collection<Integer> charSet, long seed = 0) {
        return toCharArray(number, new CharSet(charSet), seed)
    }
    /**
     * Convert number to string
     * @param number
     * @param charSet
     * @param seed
     * @return
     */
    static String toString(BigInteger number, CharSet charSet, long seed = 0) {
        LpCode lpCode = new LpCode(charSet, charSet, seed)
        char[] chars = toStr(number, charSet)
        return (seed ? lpCode.randomize(chars, true) : chars).toString()
    }
    /**
     * Convert number to string
     * @param number
     * @param charSet
     * @param seed
     * @return
     */
    static String toString(BigInteger number, Collection<Integer> charSet, long seed = 0) {
        return toString(number, new CharSet(charSet), seed)
    }

    /**
     * The following methods are static wrappers for `translate`
     * @param chars : char array or String
     * @param from  : CharSet or List<Integer>
     * @param to    : CharSet or List<Integer>
     * @return char array or String
     */
    static char[] translate(char[] chars, CharSet from, CharSet to) {
        return new LpCode(from, to).translate(chars)
    }
    static char[] translate(char[] chars, Collection<Integer> from, CharSet to) {
        return new LpCode(from, to).translate(chars)
    }
    static char[] translate(char[] chars, CharSet from, Collection<Integer> to) {
        return new LpCode(from, to).translate(chars)
    }
    static char[] translate(char[] chars, Collection<Integer> from, Collection<Integer> to) {
        return new LpCode(from, to).translate(chars)
    }
    static String translate(String str, CharSet from, CharSet to) {
        return new LpCode(from, to).translate(str.toCharArray()).toString()
    }
    static String translate(String str, Collection<Integer> from, CharSet to) {
        return new LpCode(from, to).translate(str.toCharArray()).toString()
    }
    static String translate(String str, CharSet from, Collection<Integer> to) {
        return new LpCode(from, to).translate(str.toCharArray()).toString()
    }
    static String translate(String str, Collection<Integer> from, Collection<Integer> to) {
        return new LpCode(from, to).translate(str.toCharArray()).toString()
    }
    /**
     * Translates from one charset to another
     * `Translate` won't encode, it is just a 1 to 1 conversion.
     * For example:  A -> üÖ∞ -> üÖê -> üÑ∞ -> a -> 1
     *
     * NOTE: In the case the target charset uses a out-of-bounds character,
     * it will not translate
     *
     * @param str
     * @return
     */
    char[] translate(char[] str) {
        String res = ""
        List<Integer> cps = getCodePoints(str.toString())
        cps.each {
            int idx = input.getPosition(it)
            if(idx >= 0) {
                if(idx <= output.length) {
                    res += Character.toString(output[idx])
                } else {
                    res += Character.toString(it)
                }
            } else {
                res += Character.toString(it)
            }
        }
        return res.toCharArray()
    }
    /**
     * Encode an array of characters
     * @param str
     * @return
     */
    char[] encode(char[] str) {
        if (seed) {
            str = randomize(str)
        }
        BigInteger num = toNum(str, input)
        return toStr(num, output)
    }
    /**
     * Encode an input stream and write it into an output stream
     * @param inputStream : string to encode
     * @param outputStream
     */
    void encode(InputStream inputStream, OutputStream outputStream, Collection<Integer> glue, int chunkCharSize = chunkSize) {
        InputStreamReader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)
        BufferedReader br = new BufferedReader(reader)
        OutputStreamWriter writer = new OutputStreamWriter(outputStream)
        CharBuffer buff = CharBuffer.allocate(chunkSize)
        boolean init = false // flag to know if we already started
        while(br.read(buff) > 0) {
            buff.flip()
            String encoded = encode(buff.chars).toString()
            String sep = init ? glue.collect { Character.toString(it) }.join("") : ""
            writer.write(sep + encoded)
            writer.flush()
            buff.clear()
            init = true
        }
    }
    void encode(InputStream inputStream, OutputStream outputStream, int glue = glueChar, int chunkCharSize = chunkSize) {
        encode(inputStream, outputStream, [glue], chunkCharSize)
    }
    void encode(InputStream inputStream, OutputStream outputStream, String glue, int chunkCharSize = chunkSize) {
        encode(inputStream, outputStream, getCodePoints(glue), chunkCharSize)
    }
    /**
     * Encode splitting the input string in chunks and glue them with some separator
     * This method helps to reduce the memory consumption by trading cpu usage
     * @param str
     * @param glue
     * @param chunkSize
     * @return
     */
    String encodeByChunks(char[] str, Collection<Integer> glue, int chunkCharSize = chunkSize) {
        List<String> buff = []
        glue.each {
            output.chars.removeElement(it) // Remove it from charset if it is included
        }
        (0..str.length - 1).step(chunkCharSize).each {
            int next = it + chunkCharSize
            if(next > str.length - 1) { next = str.length }
            buff << encode(str.toList().subList(it, next).toArray() as char[]).toString()
        }
        return buff.join(codePointsToString(glue))
    }
    String encodeByChunks(char[] str, int glue = glueChar, int chunkCharSize = chunkSize) {
        return encodeByChunks(str, [glue], chunkCharSize)
    }
    String encodeByChunks(char[] str, String glue, int chunkCharSize = chunkSize) {
        return encodeByChunks(str, getCodePoints(glue), chunkCharSize)
    }
    /**
     * Decode an array of characters
     * @param str
     * @return
     */
    char[] decode(char[] str) {
        BigInteger num = toNum(str, output)
        str = toStr(num, input)
        if (seed) {
            str = randomize(str, true)
        }
        return str
    }
    /**
     * Decode an input stream and write it into an output stream
     * @param inputStream : encoded string
     * @param outputStream
     */
    void decode(InputStream inputStream, OutputStream outputStream, Collection<Integer> glue) {
        OutputStreamWriter writer = new OutputStreamWriter(outputStream)
        Scanner scanner = new Scanner(inputStream)
        String div = codePointsToString(glue)
        scanner.useDelimiter(Pattern.quote(div))
        while(scanner.hasNext()) {
            String part = scanner.next().replaceAll(div, "")
            String decoded = decode(part.toCharArray()).toString()
            writer.write(decoded)
            writer.flush()
        }
    }
    void decode(InputStream inputStream, OutputStream outputStream, int glue = glueChar) {
        decode(inputStream, outputStream, [glue])
    }
    void decode(InputStream inputStream, OutputStream outputStream, String glue) {
        decode(inputStream, outputStream, getCodePoints(glue))
    }
    /**
     * Decode a string which was previously encoded by "encodeByChunks"
     * @param str
     * @param glue
     * @return
     */
    String decodeByChunks(char[] str, Collection<Integer> glue) {
        List<String> buff = []
        glue.each {
            output.chars.removeElement(it) // Remove it from charset if it is included
        }
        String div = codePointsToString(glue)
        str.toString().tokenize(div).each {
            buff << decode(it.toCharArray()).toString()
        }
        return buff.join("")
    }
    String decodeByChunks(char[] str, int glue = glueChar) {
        return decodeByChunks(str, [glue])
    }
    String decodeByChunks(char[] str, String glue) {
        return decodeByChunks(str, getCodePoints(glue))
    }
    /**
     * Converts an array of characters to a number
     * @param chars
     * @param charset
     * @return
     */
    static protected BigInteger toNum(char[] chars, CharSet charset) {
        String str = chars.toString()
        List<Integer> codePoints = getCodePoints(str)
        int len = codePoints.size()
        BigInteger n = 0
        codePoints.eachWithIndex {
            int cp, int s ->
                int r = charset.getPosition(cp)
                if(r == -1) { // Not found in charset
                    Log.w("Character: [%s](0x%d) not found in charset: [%s ~ %s]", Character.toString(cp), cp, Character.toString(charset.chars.min()), Character.toString(charset.chars.max()))
                    r = Random.range(0, charset.length - 1) //Replace by a random character
                }
                //noinspection GrReassignedInClosureLocalVar
                n = (s == len - 1) ? n + (r + 1) : (n + (r + 1)) * (charset.length)
        }
        return n
    }

    /**
     * Get all codePoints in String
     * @param str
     * @return
     */
    static List<Integer> getCodePoints(String str) {
        List<Integer> list = []
        for (int offset = 0, s = 0; offset < str.length(); s++) {
            int cp = str.codePointAt(offset)
            list << cp
            offset += Character.charCount(cp)
        }
        return list
    }
    /**
     * Get the codePoint of a single character
     * @param str
     * @return
     */
    static Integer getCodePoint(String str) {
        return getCodePoints(str).first()
    }
    /**
     * Converts a number into an array of characters
     * @param num
     * @param charset
     * @return
     */
    static protected char[] toStr(BigInteger num, CharSet charset) {
        LinkedList<Character> anum = new LinkedList<>()
        while (num-- >= 1) {
            int c = charset.chars[(num % (charset.length)) as int]
            Character.toChars(c).toList().reverse().each {
                anum.addFirst(it)
            }
            num = num.divide((charset.length) as BigInteger)
        }
        return anum.toArray() as char[]
    }
    /**
     * Randomize a char array (keeping each character)
     * @param str
     * @param reverse
     * @return
     */
    char[] randomize(char[] chars, boolean reverse = false) {
        String str = chars.toString()
        Random random = new Random(seed)
        List<Integer> cps = getCodePoints(str)
        List<Integer> pos = (0..(cps.size() - 1)).toList()
        pos.shuffle(random)
        List<String> out = []
        pos.withIndex().each {
            int p, int i ->
                if(reverse) {
                    out[p] = Character.toString(cps[i])
                } else {
                    out[i] = Character.toString(cps[p])
                }
        }
        return out.join("").toCharArray()
    }
    /**
     * Get the list of all defined charsets
     * @return
     */
    static Map<String, CharSet> getCharsets() {
        Map charsets = [:] as Map<String, CharSet>
        try {
            LpCode.declaredFields.each {
                if (Modifier.isStatic(it.modifiers) && Modifier.isPublic(it.modifiers)) {
                    List<Integer> list = it.get(null) as List<Integer>
                    if (list.size() > 2 || it.name == "BIN") {
                        charsets[it.name] = new CharSet(list)
                    }
                }
            }
        } catch (Exception ignore) {
        }
        return charsets
    }
    /**
     * Convert codePoints to String
     * @param codes
     * @return
     */
    static String codePointsToString(Collection<Integer> codes) {
        return codes.collect { Character.toString(it) }.join("")
    }
}
